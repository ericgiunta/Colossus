[{"path":"/articles/Alt_Distrib_Starts.html","id":"general-theory","dir":"Articles","previous_headings":"","what":"General Theory","title":"Distributed Start Framework","text":"many instances, final value returned regression may depend starting point regression. cases user gets around running multiple regressions different starting points different learning rates. Colossus includes several functions built automate process several situations user may find . vignette cover descriptions several situations use distributed start functions, descriptions inputs function.","code":""},{"path":[]},{"path":"/articles/Alt_Distrib_Starts.html","id":"large-multi-dimensional-space","dir":"Articles","previous_headings":"Common Convergence Issues","what":"Large Multi-Dimensional Space","title":"Distributed Start Framework","text":"Generally speaking optimization methods used Colossus similar software based using derivatives improve log-likelihood measure deviance. methods search optimum, guaranteed global optimum. final solution may dependent initial regression conditions. model small number covariates well understood relationship covariate event, user may able start regression near global optimum. model composed hundreds covariates, becomes less likely. solution experienced user might come try multiple starting points see converge solution. Colossus tries make easier automating process. user provides Colossus initial starting point try parameters controlling many random points try generate . Currently Colossus supports uniformly generated points user provided minimum maximum values. log-linear terms generally different range acceptable values linear terms, different minimum maximum values can given log-linear terms options. one special case large multi-dimensional spaces given separate function. general multi-term models. case assumes model can split multiple independent terms can solved separately. Colossus automates splitting model simplified form, searching solution, substituting final solution simplified model full model, searching solution full model near solution simplified model.","code":""},{"path":"/articles/Alt_Distrib_Starts.html","id":"infeasible-parameter-spaces","dir":"Articles","previous_headings":"Common Convergence Issues","what":"Infeasible Parameter Spaces","title":"Distributed Start Framework","text":"risks calculated Cox Proportional Hazards Poisson model regressions generally assumed strictly positive values. use log-likelihoods scoring metric possible without assumption. However possible , regression, risk may calculated set parameters give negative probability event. illustrate consider following Poisson model. λ(α,z,β,x)=(1+α*z×exp(β×x))E(α,z,β,x,t)=λ(α,z,β,x)*t \\begin{aligned}     \\lambda(\\alpha,z, \\beta, x) = (1+\\alpha*z \\times \\exp{(\\beta \\times x)})\\\\     E(\\alpha,z, \\beta, x, t) =  \\lambda(\\alpha,z, \\beta, x) * t \\end{aligned} number events predicted interval proportional risk number person-years. exponential term always strictly positive, α\\alpha negative risk number events can also negative. Suppose several ranges parameters give negative event rates get following plot score parameter values: -2*Log-Likelihood Infeasible Points Removed plot, ranges missing data show points infeasible. goal regression reduce Log-Likelihood close 0, solution near point (−2,−2)(-2,-2). regression started near origin may end either infeasible ranges. user might catch issue -hand start regression carefully avoid infeasible ranges. Colossus can automate process sampling across range possible values automatically remove infeasible points.","code":"x <- c(   -2.0, -1.667, -1.333, -1.0, -0.667, -0.333, 0.0, -2.0, -1.667, -1.333, -1.0, -0.667,   -0.333, 0.0, -2.0, -1.667, -1.333, -1.0, -0.667, -0.333, 0.0, -2.0, -1.667, -1.333,   -1.0, -0.667, -0.333, 0.0, -2.333, -2.0, -1.667, -1.333, -0.667, -0.333, 0.0, -3.0,   -2.667, -2.333, -2.0, -1.667, -0.333, 0.0, -3.0, -2.667, -2.333, -2.0, 0.0, -3.0,   -2.667, -2.333, -2.0, -1.667, -0.333, 0.0, -3.0, -2.667, -2.333, -2.0, -1.667,   -1.333, -0.667, -0.333, 0.0, -3.0, -2.667, -2.333, -2.0, -1.667, -1.333, -1.0,   -0.667, -0.333, 0.0 ) y <- c(   -3.0, -3.0, -3.0, -3.0, -3.0, -3.0, -3.0, -2.667, -2.667, -2.667, -2.667, -2.667,   -2.667, -2.667, -2.333, -2.333, -2.333, -2.333, -2.333, -2.333, -2.333, -2.0, -2.0,   -2.0, -2.0, -2.0, -2.0, -2.0, -1.667, -1.667, -1.667, -1.667, -1.667, -1.667, -1.667,   -1.333, -1.333, -1.333, -1.333, -1.333, -1.333, -1.333, -1.0, -1.0, -1.0, -1.0,   -1.0, -0.667, -0.667, -0.667, -0.667, -0.667, -0.667, -0.667, -0.333, -0.333,   -0.333, -0.333, -0.333, -0.333, -0.333, -0.333, -0.333, 0.0, 0.0, 0.0, 0.0, 0.0,   0.0, 0.0, 0.0, 0.0, 0.0 ) c <- c(   3.0, 3.85, 4.46, 4.896, 5.209, 5.433, 5.594, 2.278, 3.333, 4.089, 4.631, 5.019, 5.297,   5.496, 1.455, 2.744, 3.667, 4.328, 4.802, 5.142, 5.385, 0.563, 2.105, 3.209, 4.0, 4.567,   4.973, 5.264, 3.674, 2.754, 1.47, 2.754, 4.333, 4.806, 5.144, 5.315, 5.045, 4.667, 4.139,   3.403, 4.667, 5.045, 5.632, 5.487, 5.283, 5.0, 5.0, 5.824, 5.755, 5.658, 5.522, 5.333,   4.702, 5.07, 5.937, 5.912, 5.877, 5.829, 5.761, 5.667, 5.351, 5.094, 5.351, 6.0, 6.0,   6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0 ) dft <- data.table(\"x\" = x, \"y\" = y, \"c\" = c) g <- ggplot() +   geom_point(data = dft, aes(     x = .data$x, y = .data$y,     color = .data$c   ), size = 4) +   scale_fill_continuous(guide = guide_colourbar(title = \"-2*Log-Likelihood\")) +   xlab(\"Linear Parameter\") +   ylab(\"Log-Linear Parameter\") g + scale_colour_viridis_c()"},{"path":"/articles/Alt_Distrib_Starts.html","id":"provided-functions","dir":"Articles","previous_headings":"","what":"Provided Functions","title":"Distributed Start Framework","text":"use parameters respective Cox Proportional Hazards Poisson model regression functions use, addition control term listing options guessing process. “rmin” “rmax” used, remaining “_min” “_max” values used instead. “guess_constant” values take priority “rmin” “rmax” values.","code":""},{"path":"/articles/Alt_Run_Opt.html","id":"general-options","dir":"Articles","previous_headings":"","what":"General Options","title":"Alternative Regression Options","text":"Cox proportional hazards Poisson model regressions additional functions can account specific situations. general situations follows: following sections review math behind basic functions option changes .","code":""},{"path":[]},{"path":"/articles/Alt_Run_Opt.html","id":"cox-proportional-hazards","dir":"Articles","previous_headings":"Stratification","what":"Cox Proportional Hazards","title":"Alternative Regression Options","text":"Cox Proportional Hazards, Log-Likelihood calculated taking ratio hazard ratio event sum hazard ratios every row risk. defines risk group every event time intervals containing event time. Intervals assumed open left closed right, events assumed take place right end point. gives following common equation Log-Likelihood: Ll=∏(ri∑j:tj∈Rirj)δi \\begin{aligned}     Ll = \\prod_{}^{n} \\left( \\frac{r_{}}{\\sum_{j: t_j \\R_i} r_j} \\right)^{\\delta_i} \\end{aligned} r denotes hazard ratios, denominator sum hazard ratios intervals containing event time, term raised power 1 interval event 0 otherwise. Different tie methods modify denominator based order events assumed, general form still stands. goal compare event interval intervals within similar time span. Stratification adds additional condition. user stratifies covariate “F” risk group split subgroups value “F”. goal becomes compare event intervals intervals similar strata time. done remove influence stratification variables calculations. code done adding additional parameter stratification column using different function call regression.","code":"Strat_Col <- \"e\" e <- RunCoxRegression_Strata(   df, time1, time2, event, names, term_n, tform, keep_constant,   a_n, modelform,   control = control, strat_col = Strat_Col )"},{"path":"/articles/Alt_Run_Opt.html","id":"poisson-regression","dir":"Articles","previous_headings":"Stratification","what":"Poisson Regression","title":"Alternative Regression Options","text":"Poisson model regression risk groups account , theory . remove influence stratification covariate new term added account effects. Colossus, Log-Linear term. following may model used without stratification: R=∑(xi⋅βi) \\begin{aligned}     R = \\sum_i (x_i \\cdot \\beta_i) \\end{aligned} stratified model may look like : R=(∑(xi⋅βi))×(1+exp(∑j(xj⋅βj))) \\begin{aligned}     R = (\\sum_i (x_i \\cdot \\beta_i)) \\times (1 + \\exp{(\\sum_j (x_j \\cdot \\beta_j))}) \\end{aligned} results associated non-stratified parameters returned default. average event rate calculated every strata level, weights calculated risks. code done adding list stratification columns using different function call regression. Colossus combines list stratification columns single interaction, matter user provides list combines .","code":"Strat_Col <- c(\"e\") e <- RunPoissonRegression_Strata(   df, pyr, event, names, term_n, tform, keep_constant,   a_n, modelform,   control = control, strat_col = Strat_Col )"},{"path":"/articles/Alt_Run_Opt.html","id":"simplified-model","dir":"Articles","previous_headings":"","what":"Simplified Model","title":"Alternative Regression Options","text":"inclusion linear subterms, additive models, multiple terms means default Colossus calculates stores every derivative assuming every value needed. equation log-linear one term, many simplifications can made. option designed make simplifications. particular one subterm type means hazard ratios derivatives can calculated directly, subterm type exponential means logarithm hazard ratio Log-Likelihood calculation simplified. tests, using simplified function able save approximately 40% time versus full code used. Assuming general parameters vignettes, code follows:","code":"e <- RunCoxRegression_Basic(   df, time1, time2, event, names,   keep_constant, a_n,   control = control )"},{"path":"/articles/Alt_Run_Opt.html","id":"non-derivative-calculation","dir":"Articles","previous_headings":"","what":"Non-Derivative Calculation","title":"Alternative Regression Options","text":"Colossus uses Newton’s method perform regression, can become computationally complex number terms formula increases. Colossus contains functions calculate scores parameter set, skip intensive derivative calculations. results used perform bisection method regression plot dependence score parameter values. Colossus current state use functions, left user’s convenience. code similar previous examples:","code":"e <- RunCoxRegression_Single(   df, time1, time2, event, names, term_n, tform,   a_n, modelform,   control = control )  e <- RunPoissonRegression_Single(   df, pyr, event, names, term_n, tform,   a_n, modelform,   control = control )"},{"path":[]},{"path":"/articles/Alt_Run_Opt.html","id":"fine-gray","dir":"Articles","previous_headings":"Competing Risks","what":"Fine-Gray","title":"Alternative Regression Options","text":"Cox PH assumption every individual recorded event naturally censored, censoring rates assumed apply every individual. violated competing event occurring. sensitivity analysis two extremes can tested. Either every person competing event treated event interest instead, assumed never experience event interest. However methods find realistic alternative. Colossus applies Fine-Gray model competing risks, instead weights contribution competing event intervals future intervals probability censored. previously established, risk groups formed measure probability individual survived time experienced event interest, given experience event time: λ(t)=limΔt→0(P(t≤T≤t+Δt) (k=1),T≥t)Δt \\begin{aligned}     \\lambda(t) = \\lim_{\\Delta t \\0} \\frac{(P(t \\leq T \\leq t + \\Delta t)\\text{ }(k=1), T \\geq t)}{\\Delta t} \\end{aligned} competing risks model adjusts probability individual survived time experienced event interest, given experience event time survived previous time experienced event: λ(t)=limΔt→0(P(t≤T≤t+Δt) (k=1),(T≥t) ((T<t) (k≠1)))Δt \\begin{aligned}     \\lambda(t) = \\lim_{\\Delta t \\0} \\frac{(P(t \\leq T \\leq t + \\Delta t)\\text{ }(k=1), (T \\geq t)\\text{ }((T < t)\\text{ }(k \\neq 1)))}{\\Delta t} \\end{aligned} means risks groups contain intervals actually risk intervals competing events treated risk. assume time-dependent covariates used, remains weight contribution competing events. goal quantify probability interval uncensored new event time given uncensored competing event time. Colossus handles fitting survival curve censoring using ratio surviving proportion weight intervals. Wi(j)=min(S(tj)S(ti),1) \\begin{aligned}    W_i(j) = min \\left(\\frac{S(t_j)}{S(t_i)},1 \\right) \\end{aligned} given event time, every competing event interval right interval limit event time every interval without events right interval limit event time. competing events weighting 1 every interval weighting set 1. code, call similar standard function. process finding weighting included . example assume event column, lung, contain 0 events, 1 primary event, 2 competing event. ID column used determine individuals events censored.","code":"df$censor <- (df$lung == 0) # censoring column made event <- \"censor\" # event type switched to censoring  plot_options <- list(   \"name\" = \"run_2\", \"verbose\" = FALSE,   \"studyID\" = \"studyID\", \"age_unit\" = \"years\" ) # modified plotting function used to get censoring weights dft <- GetCensWeight(   df, time1, time2, event, names, term_n, tform, keep_constant,   a_n, modelform,   control = control, plot_options = plot_options ) # generates a survival curve t_ref <- dft$t surv_ref <- dft$surv t_c <- df$t1 cens_weight <- approx(t_ref, surv_ref, t_c, rule = 2)$y # the surviving proportions used as censoring weight event <- \"lung\" # event switched back  e <- RunCoxRegression_CR(   df, time1, time2, event, names, term_n, tform, keep_constant,   a_n, modelform,   control = control, cens_weight = cens_weight )"},{"path":"/articles/Alt_Run_Opt.html","id":"poisson-joint-analysis","dir":"Articles","previous_headings":"Competing Risks","what":"Poisson Joint Analysis","title":"Alternative Regression Options","text":"dataset multiple outcomes often two ways Poisson models fit. Either multiple independent models fit events combined one model fit several events. methods limit models completely independent identical. true model may combination shared terms terms specific event, modeled methods. fit type model joint analysis method (Cologne, 2019) available Colossus. Suppose one table person-years, covariate, counts two events. Assume fitting event rate (λ\\lambda) event reason believe background rate (β\\beta) event. λy()=β*exp(μy*)λz()=β*exp(μz*) \\begin{aligned}     \\lambda_y() = \\beta*\\exp{(\\mu_y*)}\\\\     \\lambda_z() = \\beta*\\exp{(\\mu_z*)} \\end{aligned} one solve equations separately table split two tables, one event column. premise joint analysis write model can applied every event, including factor covariate select event solved . split tables can recombined multiple events can solved allowing shared event-specific parameters. λ(,αy,αz)=β*exp(μy*(*αy)+μz*(*αz)) \\begin{aligned}     \\lambda(,\\alpha_y,\\alpha_z) = \\beta*\\exp{(\\mu_y*(*\\alpha_y) + \\mu_z*(*\\alpha_z))} \\end{aligned} Colossus includes several functions apply method, function produces input joint analysis regression functions additionally run regressions. general converts table lists model parameters input regression. Colossus generally accepts series vectors describe elements model. joint analysis, Colossus instead expects lists. list expected contain vectors shared elements elements specific event. Colossus expects list names either “shared” event column names. function returns list contains combined table vectors. results used input available regression functions. Colossus also includes wrapper functions directly call Poisson model regression function. method applied Cox model assuming every event baseline hazard. However intended use, wrapper function included.","code":"a <- c(0, 0, 0, 1, 1, 1) b <- c(1, 1, 1, 2, 2, 2) c <- c(0, 1, 2, 2, 1, 0) d <- c(1, 1, 0, 0, 1, 1) e <- c(0, 1, 1, 1, 0, 0) df <- data.table(\"t0\" = a, \"t1\" = b, \"e0\" = c, \"e1\" = d, \"fac\" = e) time1 <- \"t0\" time2 <- \"t1\" df$pyr <- df$t1 - df$t0 pyr <- \"pyr\" events <- c(\"e0\", \"e1\") names_e0 <- c(\"fac\") names_e1 <- c(\"fac\") names_shared <- c(\"t0\", \"t0\") term_n_e0 <- c(0) term_n_e1 <- c(0) term_n_shared <- c(0, 0) tform_e0 <- c(\"loglin\") tform_e1 <- c(\"loglin\") tform_shared <- c(\"quad_slope\", \"loglin_top\") keep_constant_e0 <- c(0) keep_constant_e1 <- c(0) keep_constant_shared <- c(0, 0) a_n_e0 <- c(-0.1) a_n_e1 <- c(0.1) a_n_shared <- c(0.001, -0.02) name_list <- list(\"shared\" = names_shared, \"e0\" = names_e0, \"e1\" = names_e1) term_n_list <- list(\"shared\" = term_n_shared, \"e0\" = term_n_e0, \"e1\" = term_n_e1) tform_list <- list(\"shared\" = tform_shared, \"e0\" = tform_e0, \"e1\" = tform_e1) keep_constant_list <- list(   \"shared\" = keep_constant_shared,   \"e0\" = keep_constant_e0, \"e1\" = keep_constant_e1 ) a_n_list <- list(\"shared\" = a_n_shared, \"e0\" = a_n_e0, \"e1\" = a_n_e1) Joint_Multiple_Events(   df, events, name_list, term_n_list,   tform_list, keep_constant_list, a_n_list ) #> $df #>        t0    t1 events    e0    e1   fac   pyr fac_e0 fac_e1 #>     <num> <num>  <num> <num> <num> <num> <num>  <num>  <num> #>  1:     0     1      0     1     0     0     1      0      0 #>  2:     0     1      1     1     0     1     1      1      0 #>  3:     0     1      2     1     0     1     1      1      0 #>  4:     1     2      2     1     0     1     1      1      0 #>  5:     1     2      1     1     0     0     1      0      0 #>  6:     1     2      0     1     0     0     1      0      0 #>  7:     0     1      1     0     1     0     1      0      0 #>  8:     0     1      1     0     1     1     1      0      1 #>  9:     0     1      0     0     1     1     1      0      1 #> 10:     1     2      0     0     1     1     1      0      1 #> 11:     1     2      1     0     1     0     1      0      0 #> 12:     1     2      1     0     1     0     1      0      0 #>  #> $names #> [1] \"t0\"     \"t0\"     \"fac_e0\" \"fac_e1\" #>  #> $term_n #> [1] 0 0 0 0 #>  #> $tform #> [1] \"quad_slope\" \"loglin_top\" \"loglin\"     \"loglin\"     #>  #> $keep_constant #> [1] 0 0 0 0 #>  #> $a_n #> [1]  0.001 -0.020 -0.100  0.100 der_iden <- 0 modelform <- \"M\" fir <- 0 control <- list(   \"ncores\" = 1, \"lr\" = 0.75, \"maxiter\" = 10, \"halfmax\" = 5, \"epsilon\" = 1e-3,   \"dbeta_max\" = 0.5, \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE, \"ties\" = \"breslow\", \"double_step\" = 1 ) guesses_control <- list(   \"maxiter\" = 10, \"guesses\" = 10, \"lin_min\" = 0.001, \"lin_max\" = 1,   \"loglin_min\" = -1, \"loglin_max\" = 1, \"lin_method\" = \"uniform\", \"loglin_method\" = \"uniform\",   strata = FALSE ) Strat_Col <- \"f\" e <- RunPoissonRegression_Joint_Omnibus(   df, pyr, events, name_list, term_n_list,   tform_list, keep_constant_list, a_n_list,   modelform,   control = control, strat_col = Strat_Col ) Interpret_Output(e) #> |-------------------------------------------------------------------| #> Final Results #>    Covariate    Subterm Term Number Central Estimate Standard Deviation #>       <char>     <char>       <int>            <num>              <num> #> 1:    fac_e0     loglin           0        0.5742948          0.4676073 #> 2:    fac_e1     loglin           0       -1.0346366          1.0090321 #> 3:        t0 loglin_top           0       -0.0200000                NaN #> 4:        t0 quad_slope           0       -0.1646741                NaN #>  #> Poisson Model Used #> -2*Log-Likelihood: 20.89,  Deviation: 6.44,  AIC: 14.44,  BIC: 30.83 #> Iterations run: 6 #> maximum step size: 1.00e+00, maximum first derivative: 5.12e-04 #> Analysis converged #> Run finished in 0.07 seconds #> |-------------------------------------------------------------------|"},{"path":"/articles/Alt_Run_Opt.html","id":"distributed-starts","dir":"Articles","previous_headings":"","what":"Distributed starts","title":"Alternative Regression Options","text":"distributed start framework built Cox proportional hazards Poisson functions allows user provide list multiple starting points. Regressions 1 guess use “maxiter” control option, regressions multiple guesses use “maxiters” control option pass list iterations per guess. default Colossus runs guess 1 iteration, picks best guess, runs full number iterations starting best guess. Advanced users can select different number iterations guess.","code":"a_n <- list(c(1, 1, 1), c(1, 2, 1), c(1, 2, 2), c(2, 1, 1))  control$maxiter <- 5 # runs each (4) starts 1 iteration, and then runs the best 5 iterations control$maxiters <- c(1, 1, 1, 1, 5) # runs each (4) starts 1 iteration, and then runs the best 5 iterations control$maxiters <- c(5, 5, 5, 5, 5) # runs each (4) starts 5 iterations, and then runs the best 5 iterations  e <- RunCoxRegression_Omnibus(df, time1, time2, event,   names, term_n, tform, keep_constant,   a_n, modelform,   control = control )"},{"path":"/articles/Control_Options.html","id":"general-use","dir":"Articles","previous_headings":"","what":"General Use","title":"List of Control Options","text":"three control lists used Colossus user can use customize regression, three functions defined assign default values missing list items. following sections go control list, used, every item assigned means.","code":""},{"path":"/articles/Control_Options.html","id":"standard-control-list","dir":"Articles","previous_headings":"General Use","what":"Standard Control List","title":"List of Control Options","text":"“control” variable used every regression function. list focuses options control convergence criteria standard Cox proportional hazards options.","code":""},{"path":"/articles/Control_Options.html","id":"model-control-list","dir":"Articles","previous_headings":"General Use","what":"Model Control List","title":"List of Control Options","text":"“model_control” variable used primarily omnibus functions. non-omnibus functions use list select non-standard modeling options. log_bound method used, several additional control options used: Several options available matched case-control conditional logistic regression:","code":""},{"path":"/articles/Control_Options.html","id":"guess-control-list","dir":"Articles","previous_headings":"General Use","what":"Guess Control List","title":"List of Control Options","text":"“guesses_control” variable used distributed start functions. options used control number scope distributed initial parameter sets used.","code":""},{"path":"/articles/Dose_Formula_Inputs.html","id":"dose-response-formula","dir":"Articles","previous_headings":"","what":"Dose Response Formula","title":"Dose Response Formula Terms","text":"previously discussed, Colossus features term composed sum multiple linear non-linear term can used define many dose response curves used radiation epidemiology. terms referred dose response terms, nothing prohibiting used non-dose covariates. following formula available, reproduced starting description vignette. SNL=∑(αi×exp(xi⋅βi))+∑(βi⋅(xi)2)+∑iFLT+∑iFSTP+∑iFLQ+∑iFLEXPFLT={αi⋅(x−βi)(x>βi)0elseFSTP={αi(x>βi)0elseFLQ={βi⋅x(x>αi)λi⋅x2+νielseFLEXP={βi⋅x(x>αi)λi−exp(νi+μ⋅x)elseTj=SLL,j×SL,j×SPL,j×SNL,j \\begin{aligned}     S_{NL}=\\sum_i (\\alpha_i \\times \\exp(x_i \\cdot \\beta_i)) + \\sum_i (\\beta_i \\cdot (x_i)^2) + \\sum_i F_{LT} + \\sum_i F_{STP} + \\sum_i F_{LQ} + \\sum_i F_{LEXP}\\\\     F_{LT} = \\begin{cases} \\alpha_i \\cdot (x-\\beta_i) & (x>\\beta_i) \\\\ 0 &\\text{else} \\end{cases}\\\\     F_{STP} = \\begin{cases} \\alpha_i & (x>\\beta_i) \\\\ 0 &\\text{else} \\end{cases}\\\\     F_{LQ} = \\begin{cases} \\beta_i \\cdot x & (x>\\alpha_i) \\\\ \\lambda_i \\cdot x^2 + \\nu_i &\\text{else} \\end{cases}\\\\     F_{LEXP} = \\begin{cases} \\beta_i \\cdot x & (x>\\alpha_i) \\\\ \\lambda_i - \\exp{(\\nu_i + \\mu \\cdot x)} &\\text{else} \\end{cases}\\\\     T_j=S_{LL,j} \\times S_{L,j} \\times S_{PL,j} \\times S_{NL,j} \\end{aligned} every subterm type 1 3 parameters fully define curve. Linear-Quadratic Linear-Exponential curves continuously-differentiable, 2-3 parameters can set. λLQ=βLQ/(2αLQ)νLQ=(βLQ*αLQ)/2νLEXP=ln(βLEXP)−ln(μLEXP)+μLEXP*αLEXPλLEXP=βLEXP*αLEXP+exp(νLEXP−μLEXP*αLEXP) \\begin{aligned}     \\lambda_{LQ} = \\beta_{LQ}/(2\\alpha_{LQ})\\\\     \\nu_{LQ} = (\\beta_{LQ}*\\alpha_{LQ})/2\\\\     \\nu_{LEXP} = \\ln(\\beta_{LEXP})-\\ln(\\mu_{LEXP})+\\mu_{LEXP}*\\alpha_{LEXP}\\\\     \\lambda_{LEXP} = \\beta_{LEXP}*\\alpha_{LEXP}+exp(\\nu_{LEXP}-\\mu_{LEXP}*\\alpha_{LEXP}) \\end{aligned}","code":""},{"path":"/articles/Dose_Formula_Inputs.html","id":"using-the-different-subterms","dir":"Articles","previous_headings":"","what":"Using The Different subterms","title":"Dose Response Formula Terms","text":"linear-exponential linear-quadratic curves must either completely fixed completely free. contrast exponential, linear threshold, step function curves can partially fixed. exponential term can provided covariate exponent assume magnitude 1. linear threshold step functions can provided fixed threshold covariate, can used define linear--threshold model combination linear step functions known threshold. One issue dose response formulas order important. instance, loglin_slope listed prior loglin_top used. slope Linear Threshold Step Functions given prior intercepts. Slopes listed prior intercept Linear-Quadratic Linear-Exponential models lin_exp_exp_slope listed last. “Correct_Formula_Order” function provided handle correct order. Colossus automatically calls function prior regression.","code":"term_n <- c(0, 1, 1, 0, 0) tform <- c(\"loglin\", \"quad_slope\", \"lin\", \"lin_int\", \"lin_slope\") keep_constant <- c(0, 0, 0, 1, 0) a_n <- c(1, 2, 3, 4, 5) names <- c(\"a\", \"a\", \"a\", \"a\", \"a\") val <- Correct_Formula_Order(term_n, tform, keep_constant, a_n, names) term_n <- val$term_n tform <- val$tform keep_constant <- val$keep_constant a_n <- val$a_n der_iden <- val$der_iden names <- val$names"},{"path":"/articles/Equation_Expression.html","id":"prospective-feature-presented-for-user-suggestion","dir":"Articles","previous_headings":"","what":"Prospective feature, presented for user suggestion","title":"Unified Equation Representation","text":"default method specify survival model using series vectors can overly complicated times. felt wasn’t straight-forward typical R users, made complicated translate model script input. plan add two functions: conversion simple string expression model regression call, function plot hazard ratio rate equation LaTeX.","code":""},{"path":"/articles/Equation_Expression.html","id":"equation-expression","dir":"Articles","previous_headings":"Prospective feature, presented for user suggestion","what":"Equation Expression","title":"Unified Equation Representation","text":"basic idea first function take string expression, similar model objects Survival package, contains information required easily read format. intended serve three functions: simplify required input, make easier add multiple elements subterm, make easier add factors. Generally survival model defined using Surv object, initialized interval event columns, list columns. Colossus can handle much complicated models, definition complicated. Instead Surv object, model specified ‘cox’ ‘poisson’. Based number entries, format time interval assumed. right side equation listed similarly. Columns added subterm types (loglinear, linear, plinear). subterm list columns term number. Finally method combine terms added separate item (multiplicative, additive). prevent issues function definitions, model equation stored string. Surv(interval, event)   name + ... + factor(name)’Survival(interval, event)   subterm(name, factor(name), term_number) + ... + term_model()’ \\begin{aligned}     \\text{Surv(interval, event) ~ name + ... + factor(name)} \\\\     \\text{'Survival(interval, event) ~ subterm(name, factor(name), term_number) + ... + term_model()'} \\end{aligned} factor option can used without baseline specified. default baseline used. baseline can added changing ‘factor(name)’ ‘factor(name;baseline=level)’. valid baseline used, proper factor included model expression final datatable returned. invalid baseline used warning thrown functions runs without baseline. following expressions equivalent. Different model formulas subterm types added need. Please contact developer methods want use yet added. following tables cover subterms term models currently implemented. Every option listed multiple equivalent aliases refer subterm model formula.","code":"term_n <- c(0, 0, 1) tform <- c(\"loglin\", \"loglin\", \"lin\") names <- c(\"dose0\", \"dose1\", \"dose2\") modelform <- \"M\" tstart <- \"t0\" tend <- \"t1\" event <- \"lung\"  Model_Eq <- \"cox(t0, t1, lung) ~ loglinear(dose0, dose1, 0) + linear(dose2, 1) + multiplicative()\" Model_Eq <- \"cox(t0, t1, lung) ~ loglinear(dose0, dose1) + linear(dose2, 1)\"  df <- data.table(\"dose0\" = 1:4, \"dose1\" = 2:5, \"dose2\" = 3:6) Convert_Model_Eq(Model_Eq, df) #> $term_n #> [1] 0 0 1 #>  #> $tform #> [1] \"loglin\" \"loglin\" \"lin\"    #>  #> $names #> [1] \"dose0\" \"dose1\" \"dose2\" #>  #> $modelform #> [1] \"M\" #>  #> $survival_model_type #> [1] \"cox\" #>  #> $start_age #> [1] \"t0\" #>  #> $end_age #> [1] \"t1\" #>  #> $person_year #> [1] \"NONE\" #>  #> $event #> [1] \"lung\" #>  #> $strata #> [1] \"NONE\" #>  #> $data #>    dose0 dose1 dose2 #>    <int> <int> <int> #> 1:     1     2     3 #> 2:     2     3     4 #> 3:     3     4     5 #> 4:     4     5     6"},{"path":"/articles/Equation_Expression.html","id":"model-visualization","dir":"Articles","previous_headings":"Prospective feature, presented for user suggestion","what":"Model Visualization","title":"Unified Equation Representation","text":"second function intended display equation. function currently developed. Based required packages current formats considered : plain-text output, LaTeX code output, directly plotting equation graph display. method currently implemented use.","code":""},{"path":"/articles/Excess_and_Predicted_Cases.html","id":"general-theory","dir":"Articles","previous_headings":"","what":"General Theory","title":"Excess and Predicted Cases","text":"field radiation epidemiology, common question “many additional cancer cases occurred due radiation exposures?”. often generalized question many cases background cases many cases excess cases. calculated splitting poisson model background term excess term. Colossus background term assumed first term, every term assumed causing excess cases. Colossus function, RunPoissonEventAssignment, calculates number background/excess cases average predicted counts true counts. Let us assume following model event rate: R(β,x,α,D)=exp(β⋅x)*(1+α⋅D) \\begin{aligned}     R(\\beta,x, \\alpha, D)=\\exp(\\beta \\cdot x)*(1 + \\alpha \\cdot D) \\end{aligned} total rate (RR) composed background rate (RBKR_{BK}) excess rate (REXR_{EX}). cases row total (cc) background/excess count (cBK,cEXc_{BK}, c_{EX}). Additionally, every row measure person-time (tt). Colossus also computes predicted number total, background, excess cases (P,PBK.PEXP, P_{BK}. P_{EX}). every model assume average number background cases background rate multiplied time, remaining cases excess, true number background/excess cases proportional predicted cases. R=exp(β⋅x)*(1+α⋅D)RBK=exp(β⋅x)P=PBK+PEXP=R*tPBK=RBK*tPEX=P−PBKc=cBK+cEXcBK=c*PBKPcEX=c*PEXP \\begin{aligned}     R = \\exp(\\beta \\cdot x)*(1 + \\alpha \\cdot D)\\\\     R_{BK} = \\exp(\\beta \\cdot x)\\\\     P = P_{BK} + P_{EX}\\\\     P = R * t\\\\     P_{BK} = R_{BK} * t\\\\     P_{EX} = P - P_{BK}\\\\     c = c_{BK} + c_{EX}\\\\     c_{BK} = c * \\frac{P_{BK}}{P}\\\\     c_{EX} = c * \\frac{P_{EX}}{P} \\end{aligned} Colossus returns two matrices, one true cases one predicted cases. matrix three columns events assigned background, excess, total.","code":"names <- c(\"x\", \"D\") term_n <- c(0, 1) tform <- c(\"loglin\", \"lin\") modelform <- \"M\" fir <- 0  a_n <- c(0.1, 0.1) names <- c(\"x\", \"D\") term_n <- c(0, 1) tform <- c(\"loglin\", \"lin\") modelform <- \"M\" fir <- 0 a_n <- c(0.1, 0.1) keep_constant <- rep(0, length(names)) der_iden <- 0 control <- list(\"Ncores\" = 2, \"verbose\" = F) e <- RunPoissonEventAssignment(df, pyr, event, names, Term_n, tform, keep_constant, a_n, modelform, control = control)  e0 <- e$predict e1 <- e$caused  BK <- e0[, 1] EX <- e0[, 2] Total <- e0[, 3]"},{"path":"/articles/Grad_Hess.html","id":"optimization-theory","dir":"Articles","previous_headings":"","what":"Optimization Theory","title":"Gradient and Hessian Approaches","text":"Colossus offers three levels score calculation, calculating score, calculating score first derivative, calculating score first second derivatives. second third options correspond Gradient Descent Newton-Raphson optimization approaches. goal vignette discuss methods different, circumstances might appropriate. cases algorithm designed iteratively change parameter estimates approach set parameter values optimize score. major difference much information calculated used. Newton-Raphson algorithm calculates second derivative matrix, inverts , solves linear system equations set first derivative vector zero. method establishes magnitude direction every step. every step several time-intensive calculations, new parameter estimates informed. algorithm Colossus uses learning rate (η\\eta) maximum allowable parameter change (βmax\\beta_{max}). Δβ×∂2LL∂β2≈−∂LL∂βΔβ=−η∂LL∂βt×(∂2LL∂βt2)−1βt+1=βt+sign(Δβ)*min([|Δβ|,βmax]) \\begin{aligned}     \\Delta \\beta \\times \\frac{\\partial^2 LL}{\\partial \\beta^2} \\approx - \\frac{\\partial LL}{\\partial \\beta} \\\\     \\Delta \\beta = - \\eta \\frac{\\partial LL}{\\partial \\beta_{t}} \\times \\left ( \\frac{\\partial^2 LL}{\\partial \\beta_{t}^2} \\right)^{-1} \\\\     \\beta_{t+1} = \\beta_{t} + sign(\\Delta \\beta)*min \\left( \\left[ \\left|\\Delta \\beta \\right|, \\beta_{max} \\right] \\right) \\end{aligned} alternative Gradient descent approach. algorithm, first derivatives calculated used determine vector highest change score. establishes direction change parameters, multiplied learning rate (η\\eta). Similar Newton-Raphson algorithm, magnitude normalized maximum allowable parameter change (βmax\\beta_{max}). Colossus uses half-steps slowly reduce allowable step size solution approaches optimum. Gradient algorithm avoids time-intensive second-derivative calculations, takes less informed steps. iteration runs faster, iterations may required. Δβ=η*∂LL∂ββt+1=βt+sign(Δβ)*min([|Δβ|,βmax]) \\begin{aligned}    \\Delta \\beta = \\eta * \\frac{\\partial LL}{\\partial \\beta}\\\\    \\beta_{t+1} = \\beta_{t} + sign(\\Delta \\beta)*min \\left( \\left[ \\left|\\Delta \\beta \\right|, \\beta_{max} \\right] \\right) \\end{aligned} standard half-step framework likely sufficient Gradient descent algorithm. , several different optimization options added, like momentum, adadelta, adam, use previous information gradient inform step size future steps. first method, momentum, applies weighted sum (γ\\gamma) current previous step. done speed steps moving toward optimum position correct algorithm oversteps. can avoid issue oscillation around optimum value. Δβt=γ*Δβt−1+η*∂LL∂ββt+1=βt+sign(Δβt)*min([|Δβt|,βmax]) \\begin{aligned}    \\Delta \\beta_{t} = \\gamma * \\Delta \\beta_{t-1} + \\eta * \\frac{\\partial LL}{\\partial \\beta}\\\\    \\beta_{t+1} = \\beta_{t} + sign(\\Delta \\beta_{t})*min \\left( \\left[ \\left|\\Delta \\beta_{t} \\right|, \\beta_{max} \\right] \\right) \\end{aligned} next method, adadelta method, applies parameter specific learning rate tracking root mean square (RMS) gradient parameter updates within window. Instead tracking true window iteration, old estimate RMS decayed weight (γ\\gamma) added new estimate. ratio RMS parameter update RMS gradient used normalize results back correct units. small offset (ϵ\\epsilon) used avoid case division zero. gt=(∂LL∂β)tE[g2]t=γ*E[g2]t−1+(1−γ)*gt2E[Δβ2]t−1=γ*E[Δβ2]t−2+(1−γ)*Δβt−12RMS[g]t=E[g2]t+ϵRMS[Δβ]t−1=E[Δβ2]t−1+ϵΔβt=RMS[Δβ]t−1RMS[g]t*gtβt+1=βt+sign(Δβt)*min([|Δβt|,βmax]) \\begin{aligned}     g_t = \\left (\\frac{\\partial LL}{\\partial \\beta} \\right)_{t} \\\\     E[g^2]_{t} = \\gamma * E[g^2]_{t-1} + (1-\\gamma) * g^2_{t} \\\\     E[\\Delta \\beta^2]_{t-1} = \\gamma * E[\\Delta \\beta^2]_{t-2} + (1-\\gamma) * \\Delta \\beta^2_{t-1} \\\\     RMS[g]_t = \\sqrt{E[g^2]_{t} + \\epsilon} \\\\     RMS[\\Delta \\beta]_{t-1} = \\sqrt{E[\\Delta \\beta^2]_{t-1} + \\epsilon} \\\\    \\Delta \\beta_{t} = \\frac{RMS[\\Delta \\beta]_{t-1}}{RMS[g]_t} * g_t\\\\    \\beta_{t+1} = \\beta_{t} + sign(\\Delta \\beta_{t})*min \\left( \\left[ \\left|\\Delta \\beta_{t} \\right|, \\beta_{max} \\right] \\right) \\end{aligned} final method, adam, combines theory behind momentum adadelta methods. adam method tracks estimate first moment vector (mm) second moment vector (vv), weighted decay parameters (β1,β2\\beta_1, \\beta_2). bias corrected correct bias early iterations (m̂,v̂\\hat{m}, \\hat{v}). learning rate (η\\eta) second moment vector provide decaying learning rate adadelta, first moment vector provides effect similar momentum. Combined generally able stabilize gradient descent algorithms without incurring significant computational cost. gt=(∂LL∂β)tm0,v0=0,0mt=β1*mt−1+(1−β1)*gtvt=β2*vt−1+(1−β2)*gt2m̂t=mt/(1−β1t)v̂t=vt/(1−β2t)Δβt=ηv̂t+ϵ*m̂tβt+1=βt+sign(Δβt)*min([|Δβt|,βmax]) \\begin{aligned}     g_t = \\left (\\frac{\\partial LL}{\\partial \\beta} \\right)_{t} \\\\     m_0, v_0 = 0, 0 \\\\     m_t = \\beta_1 * m_{t-1} + (1-\\beta_1) * g_t \\\\     v_t = \\beta_2 * v_{t-1} + (1-\\beta_2) * g^2_t \\\\     \\hat{m}_t = m_t / (1-\\beta_1^t) \\\\     \\hat{v}_t = v_t / (1-\\beta_2^t) \\\\    \\Delta \\beta_{t} = \\frac{\\eta}{\\sqrt{\\hat{v}_t} + \\epsilon} * \\hat{m}_t \\\\    \\beta_{t+1} = \\beta_{t} + sign(\\Delta \\beta_{t})*min \\left( \\left[ \\left|\\Delta \\beta_{t} \\right|, \\beta_{max} \\right] \\right) \\end{aligned}","code":""},{"path":"/articles/Grad_Hess.html","id":"use-in-practice","dir":"Articles","previous_headings":"","what":"Use in Practice","title":"Gradient and Hessian Approaches","text":"first thing acknowledge gradient descent method may require hyperparameter tuning standard Newton-Raphson method. general may necessary run analysis multiple times different learning rates, decay terms, offset. following test example shows basic usage simple model.  Every gradient descent algorithm available tested starting point. cases algorithm approaches solution, different rates. case local extrema, standard approach fine. show fundamental differences methods. effect momentum clearly visible compared standard option, estimates oscillate quickly. differences adadelta adam also visible, adam method able converge quicker. results necessarily using optimized hyperparameters however. meant prove method best.","code":"fname <- \"tests/testthat/ll_comp_0.csv\" colTypes <- c(\"double\", \"double\", \"double\", \"integer\", \"integer\") df <- fread(fname, nThread = min(c(detectCores(), 2)), data.table = TRUE, header = TRUE, colClasses = colTypes, verbose = FALSE, fill = TRUE) set.seed(3742) df$rand <- floor(runif(nrow(df), min = 0, max = 5)) time1 <- \"t0\" time2 <- \"t1\" modelform <- \"M\" fir <- 0 der_iden <- 0 event <- \"lung\" a_n <- c(-0.1, -0.1) keep_constant <- c(0, 0)  for (method in c(\"momentum\", \"adadelta\", \"adam\", \"gradient\")) {   model_control <- list(\"gradient\" = TRUE, \"epsilon_decay\" = 1e-4)   model_control[[method]] <- TRUE   a_n <- c(-0.1, -0.1)   control <- list(\"ncores\" = 2, \"lr\" = 0.2, \"maxiters\" = c(1, 20), \"halfmax\" = 2, \"epsilon\" = 1e-6, \"deriv_epsilon\" = 1e-6, \"verbose\" = 4)   modelform <- \"M\"   e <- RunCoxRegression_Omnibus(df, time1, time2, event, names, term_n = term_n, tform = tform, keep_constant = keep_constant, a_n = a_n, modelform = modelform, control = control, model_control = model_control)   Interpret_Output(e) } x <- c(   -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.95, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.9, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.85, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.8, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.75, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.7, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.65, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.6, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.55, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.45, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.4, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.35, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.15, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, -0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ) y <- c(   -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.75, -0.7, -0.65, -0.6, -0.55, -0.5, -0.45, -0.4, -0.35, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0 ) c <- c(   264.6882, 264.033, 263.4076, 262.8126, 262.2482, 261.7146, 261.2122, 260.741, 260.3016, 259.894, 259.5182, 259.1744, 258.8626, 258.583, 258.3354, 258.1196, 257.9358, 257.7838, 257.6634, 257.5742, 257.5162, 257.489, 257.4924, 257.526, 257.5894, 257.682, 257.8038, 257.954, 258.1324, 258.3382, 258.571, 258.8304, 259.1156, 259.4264, 259.7618, 260.1214, 260.5048, 260.911, 261.3398, 261.7902, 262.2618, 263.5038, 262.8408, 262.2076, 261.6046, 261.0322, 260.4904, 259.98, 259.5008, 259.0532, 258.6374, 258.2534, 257.9016, 257.5818, 257.294, 257.0382, 256.8146, 256.623, 256.463, 256.3348, 256.238, 256.1724, 256.1378, 256.1338, 256.16, 256.2162, 256.302, 256.4168, 256.5602, 256.7318, 256.9312, 257.1578, 257.411, 257.6902, 257.995, 258.3246, 258.6788, 259.0566, 259.4576, 259.8812, 260.3266, 260.7936, 262.3582, 261.6874, 261.0464, 260.4356, 259.855, 259.3054, 258.7868, 258.2996, 257.844, 257.42, 257.028, 256.668, 256.34, 256.0442, 255.7806, 255.549, 255.3494, 255.1816, 255.0456, 254.9412, 254.868, 254.8258, 254.8144, 254.8334, 254.8824, 254.961, 255.069, 255.2056, 255.3706, 255.5634, 255.7836, 256.0306, 256.3038, 256.6026, 256.9266, 257.275, 257.6474, 258.043, 258.4614, 258.902, 259.364, 261.2514, 260.573, 259.9242, 259.3054, 258.7172, 258.1596, 257.633, 257.1378, 256.674, 256.242, 255.842, 255.4738, 255.1378, 254.834, 254.5624, 254.3228, 254.1154, 253.9398, 253.796, 253.6838, 253.603, 253.5534, 253.5346, 253.5462, 253.588, 253.6596, 253.7606, 253.8904, 254.0488, 254.2352, 254.4488, 254.6896, 254.9566, 255.2496, 255.5676, 255.9104, 256.2774, 256.6678, 257.081, 257.5164, 257.9736, 260.1838, 259.4978, 258.8414, 258.2148, 257.6186, 257.0532, 256.5186, 256.0154, 255.5436, 255.1036, 254.6956, 254.3194, 253.9754, 253.6636, 253.384, 253.1364, 252.921, 252.7378, 252.5862, 252.4664, 252.378, 252.3208, 252.2946, 252.2988, 252.3336, 252.398, 252.492, 252.6152, 252.7668, 252.9464, 253.1538, 253.3882, 253.6492, 253.936, 254.2484, 254.5856, 254.9468, 255.3318, 255.7398, 256.1702, 256.6226, 259.1556, 258.462, 257.7978, 257.1636, 256.5596, 255.9864, 255.444, 254.9328, 254.4532, 254.0052, 253.589, 253.205, 252.853, 252.5332, 252.2456, 251.9902, 251.767, 251.5758, 251.4164, 251.289, 251.193, 251.1282, 251.0946, 251.0916, 251.119, 251.1766, 251.2636, 251.3798, 251.5248, 251.6978, 251.8988, 252.1268, 252.3816, 252.6626, 252.969, 253.3004, 253.6562, 254.0358, 254.4386, 254.8638, 255.3112, 258.1668, 257.4658, 256.7942, 256.1522, 255.5406, 254.9594, 254.4092, 253.8902, 253.4026, 252.9466, 252.5226, 252.1306, 251.7706, 251.443, 251.1474, 250.8842, 250.653, 250.454, 250.287, 250.1518, 250.0482, 249.976, 249.935, 249.9248, 249.945, 249.9954, 250.0754, 250.1848, 250.323, 250.4896, 250.684, 250.9058, 251.1544, 251.4292, 251.7298, 252.0554, 252.4056, 252.7798, 253.1774, 253.5976, 254.0398, 257.2178, 256.5094, 255.8302, 255.1808, 254.5614, 253.9726, 253.4146, 252.8878, 252.3924, 251.9286, 251.4966, 251.0966, 250.7288, 250.3932, 250.0898, 249.8186, 249.5798, 249.373, 249.1982, 249.0554, 248.9442, 248.8646, 248.816, 248.7984, 248.8114, 248.8548, 248.9278, 249.0302, 249.1618, 249.3218, 249.5096, 249.7252, 249.9676, 250.2364, 250.531, 250.851, 251.1956, 251.5642, 251.9564, 252.3714, 252.8088, 256.3088, 255.593, 254.9064, 254.2494, 253.6226, 253.026, 252.4604, 251.9258, 251.4226, 250.9508, 250.511, 250.1032, 249.7276, 249.384, 249.0728, 248.7938, 248.5472, 248.3326, 248.1502, 247.9996, 247.881, 247.7938, 247.738, 247.713, 247.7188, 247.755, 247.821, 247.9166, 248.0414, 248.1948, 248.3762, 248.5852, 248.8214, 249.0842, 249.373, 249.6872, 250.0262, 250.3894, 250.7762, 251.186, 251.6182, 255.4398, 254.7166, 254.0228, 253.3584, 252.724, 252.12, 251.5466, 251.0044, 250.4934, 250.014, 249.5664, 249.1506, 248.7672, 248.4158, 248.0968, 247.81, 247.5556, 247.3332, 247.1432, 246.985, 246.8588, 246.7642, 246.7008, 246.6688, 246.6674, 246.6964, 246.7554, 246.8442, 246.9622, 247.1088, 247.2838, 247.4866, 247.7166, 247.9732, 248.256, 248.5644, 248.8976, 249.2554, 249.6368, 250.0416, 250.4688, 254.611, 253.8808, 253.1796, 252.5078, 251.866, 251.2544, 250.6736, 250.1236, 249.605, 249.1178, 248.6624, 248.239, 247.8478, 247.4886, 247.1618, 246.8674, 246.6052, 246.3752, 246.1774, 246.0118, 245.878, 245.7758, 245.7052, 245.6658, 245.6572, 245.679, 245.7312, 245.813, 245.9242, 246.0644, 246.2328, 246.4292, 246.6528, 246.9034, 247.1802, 247.4828, 247.8106, 248.1626, 248.5388, 248.9382, 249.3604, 253.8226, 253.0852, 252.377, 251.698, 251.0488, 250.4298, 249.8414, 249.2838, 248.7576, 248.2628, 247.7998, 247.3686, 246.9696, 246.6028, 246.2682, 245.966, 245.6962, 245.4586, 245.2532, 245.08, 244.9386, 244.8292, 244.7512, 244.7044, 244.6886, 244.7034, 244.7486, 244.8236, 244.928, 245.0614, 245.2234, 245.4134, 245.6308, 245.8754, 246.1462, 246.443, 246.765, 247.1116, 247.4824, 247.8764, 248.2936, 253.0748, 252.3304, 251.615, 250.9288, 250.2724, 249.646, 249.0502, 248.4852, 247.9514, 247.4492, 246.9784, 246.5396, 246.133, 245.7584, 245.4162, 245.1064, 244.8288, 244.5836, 244.3708, 244.19, 244.0412, 243.9242, 243.8388, 243.7848, 243.762, 243.7696, 243.8078, 243.876, 243.9736, 244.1004, 244.256, 244.4396, 244.6508, 244.8892, 245.154, 245.4448, 245.7612, 246.1024, 246.4676, 246.8566, 247.2686, 252.3676, 251.6164, 250.894, 250.2006, 249.537, 248.9034, 248.3004, 247.728, 247.1866, 246.6768, 246.1986, 245.7522, 245.338, 244.9558, 244.606, 244.2884, 244.0034, 243.7506, 243.5302, 243.3418, 243.1856, 243.0614, 242.9686, 242.9074, 242.8774, 242.878, 242.9092, 242.9706, 243.0614, 243.1816, 243.3306, 243.5078, 243.7128, 243.945, 244.204, 244.489, 244.7996, 245.1352, 245.4952, 245.8788, 246.2856, 251.7014, 250.9434, 250.214, 249.5136, 248.843, 248.2022, 247.5918, 247.012, 246.4634, 245.946, 245.4604, 245.0064, 244.5846, 244.195, 243.8376, 243.5126, 243.2198, 242.9596, 242.7316, 242.536, 242.3724, 242.2406, 242.1408, 242.0722, 242.035, 242.0288, 242.053, 242.1074, 242.1916, 242.3052, 242.4478, 242.6186, 242.8174, 243.0434, 243.2964, 243.5756, 243.8806, 244.2106, 244.565, 244.9434, 245.3452, 251.076, 250.3112, 249.575, 248.8678, 248.19, 247.5422, 246.9246, 246.3376, 245.7818, 245.257, 244.764, 244.3026, 243.8734, 243.4762, 243.1114, 242.7788, 242.4786, 242.2108, 241.9754, 241.7724, 241.6014, 241.4624, 241.3552, 241.2796, 241.2354, 241.222, 241.2394, 241.287, 241.3646, 241.4716, 241.6076, 241.772, 241.9646, 242.1846, 242.4316, 242.705, 243.0042, 243.3286, 243.6778, 244.0508, 244.4474, 250.4916, 249.7204, 248.9774, 248.2634, 247.5788, 246.9238, 246.2992, 245.705, 245.1418, 244.61, 244.1096, 243.6408, 243.2042, 242.7996, 242.4272, 242.0874, 241.7798, 241.5046, 241.2618, 241.0514, 240.8732, 240.727, 240.6126, 240.5298, 240.4784, 240.4582, 240.4686, 240.5096, 240.5804, 240.6808, 240.8104, 240.9684, 241.1548, 241.3688, 241.6098, 241.8774, 242.1708, 242.4898, 242.8334, 243.2014, 243.5928, 249.9484, 249.1706, 248.421, 247.7004, 247.0088, 246.347, 245.7154, 245.1142, 244.544, 244.0048, 243.4972, 243.0212, 242.5772, 242.1654, 241.7858, 241.4384, 241.1234, 240.841, 240.591, 240.3732, 240.1876, 240.0342, 239.9128, 239.823, 239.7646, 239.7374, 239.741, 239.7752, 239.8394, 239.9332, 240.0564, 240.2082, 240.3882, 240.5962, 240.8312, 241.093, 241.3808, 241.6942, 242.0326, 242.3952, 242.7814, 249.4464, 248.6622, 247.9062, 247.1788, 246.4806, 245.812, 245.1736, 244.5654, 243.988, 243.4418, 242.927, 242.444, 241.9928, 241.5736, 241.1866, 240.8322, 240.51, 240.2202, 239.9628, 239.7378, 239.5452, 239.3846, 239.256, 239.1592, 239.094, 239.0598, 239.0568, 239.0842, 239.1418, 239.229, 239.3458, 239.4914, 239.6654, 239.8672, 240.0964, 240.3522, 240.6344, 240.9424, 241.2752, 241.6326, 242.0138, 248.9858, 248.1952, 247.4328, 246.699, 245.9942, 245.3188, 244.6736, 244.0586, 243.4744, 242.9212, 242.3994, 241.9092, 241.4508, 241.0244, 240.6304, 240.2686, 239.9392, 239.6424, 239.3778, 239.1458, 238.946, 238.7782, 238.6426, 238.539, 238.4668, 238.4258, 238.416, 238.4366, 238.4876, 238.5686, 238.679, 238.8182, 238.9862, 239.182, 239.4052, 239.6554, 239.932, 240.2344, 240.5618, 240.914, 241.29, 248.5664, 247.7698, 247.001, 246.2608, 245.5494, 244.8676, 244.2156, 243.5938, 243.0028, 242.4428, 241.914, 241.4168, 240.9514, 240.518, 240.1168, 239.748, 239.4116, 239.1076, 238.836, 238.5968, 238.39, 238.2154, 238.0728, 237.9622, 237.8832, 237.8354, 237.8188, 237.833, 237.8776, 237.952, 238.056, 238.1892, 238.351, 238.5408, 238.7582, 239.0026, 239.2736, 239.5706, 239.8928, 240.2396, 240.6106, 248.1884, 247.3856, 246.6108, 245.8642, 245.1466, 244.4582, 243.7998, 243.1714, 242.5736, 242.0068, 241.4712, 240.9672, 240.4948, 240.0546, 239.6464, 239.2706, 238.927, 238.616, 238.3374, 238.0914, 237.8776, 237.696, 237.5466, 237.429, 237.3434, 237.289, 237.2658, 237.2734, 237.3114, 237.3796, 237.4774, 237.6044, 237.76, 237.944, 238.1556, 238.3944, 238.6598, 238.9512, 239.268, 239.6098, 239.9758, 247.8518, 247.0432, 246.2622, 245.5096, 244.7856, 244.091, 243.426, 242.7912, 242.1868, 241.6132, 241.071, 240.5602, 240.081, 239.6338, 239.2188, 238.8362, 238.4858, 238.1678, 237.8824, 237.6294, 237.4088, 237.2204, 237.0642, 236.94, 236.8474, 236.7866, 236.7568, 236.758, 236.7896, 236.8514, 236.943, 237.064, 237.2136, 237.3918, 237.5976, 237.8308, 238.0906, 238.3766, 238.6882, 239.0248, 239.3858, 247.5568, 246.7422, 245.9552, 245.1966, 244.4666, 243.7656, 243.0944, 242.4532, 241.8424, 241.2624, 240.7134, 240.196, 239.7102, 239.2564, 238.8346, 238.445, 238.0878, 237.7632, 237.4708, 237.211, 236.9838, 236.7886, 236.6258, 236.4948, 236.3958, 236.3284, 236.2922, 236.2868, 236.3122, 236.368, 236.4534, 236.5682, 236.712, 236.8842, 237.0844, 237.312, 237.5664, 237.847, 238.1534, 238.485, 238.841, 247.303, 246.4826, 245.69, 244.9254, 244.1894, 243.4824, 242.805, 242.1576, 241.5404, 240.954, 240.3986, 239.8746, 239.3822, 238.9218, 238.4934, 238.0972, 237.7334, 237.402, 237.103, 236.8366, 236.6026, 236.4008, 236.2314, 236.094, 235.9884, 235.9146, 235.872, 235.8604, 235.8796, 235.929, 236.0084, 236.1174, 236.2554, 236.4218, 236.6164, 236.8384, 237.0874, 237.3628, 237.664, 237.9904, 238.3416, 247.0904, 246.2648, 245.4664, 244.696, 243.9542, 243.2412, 242.5578, 241.9042, 241.2808, 240.6882, 240.1264, 239.5962, 239.0974, 238.6304, 238.1956, 237.7928, 237.4224, 237.0846, 236.779, 236.506, 236.2654, 236.0572, 235.8814, 235.7374, 235.6256, 235.5452, 235.4964, 235.4786, 235.4918, 235.5352, 235.6086, 235.7116, 235.8438, 236.0046, 236.1936, 236.4102, 236.6538, 236.924, 237.22, 237.5416, 237.8878, 246.9194, 246.0882, 245.2844, 244.5084, 243.7608, 243.0422, 242.3528, 241.6932, 241.0638, 240.465, 239.8972, 239.3606, 238.8554, 238.3822, 237.941, 237.5318, 237.155, 236.8108, 236.4988, 236.2194, 235.9724, 235.7578, 235.5756, 235.4254, 235.3072, 235.2206, 235.1656, 235.1418, 235.1488, 235.1864, 235.2538, 235.3512, 235.4776, 235.6328, 235.8164, 236.0274, 236.2658, 236.5308, 236.822, 237.1386, 237.48, 246.7896, 245.953, 245.1438, 244.3624, 243.6094, 242.885, 242.1898, 241.5244, 240.8892, 240.2844, 239.7106, 239.1678, 238.6566, 238.1772, 237.7296, 237.3144, 236.9314, 236.5806, 236.2624, 235.9768, 235.7236, 235.5028, 235.3142, 235.1578, 235.0334, 234.9408, 234.8798, 234.85, 234.851, 234.8826, 234.9446, 235.036, 235.157, 235.3066, 235.4848, 235.6906, 235.9238, 236.1838, 236.47, 236.7816, 237.1184, 246.7008, 245.8594, 245.0448, 244.2582, 243.4996, 242.7698, 242.069, 241.398, 240.757, 240.1464, 239.5666, 239.018, 238.5008, 238.0154, 237.5618, 237.1404, 236.7512, 236.3944, 236.07, 235.7782, 235.5188, 235.292, 235.0974, 234.9348, 234.8044, 234.706, 234.639, 234.6032, 234.5986, 234.6244, 234.6806, 234.7666, 234.882, 235.0264, 235.1992, 235.3998, 235.628, 235.8828, 236.1642, 236.471, 236.803, 246.6532, 245.8068, 244.9874, 244.1954, 243.4316, 242.6964, 241.9902, 241.3138, 240.6672, 240.0508, 239.4654, 238.911, 238.388, 237.8966, 237.4372, 237.0098, 236.6148, 236.252, 235.9216, 235.6238, 235.3584, 235.1256, 234.925, 234.7566, 234.6204, 234.516, 234.4432, 234.4018, 234.3914, 234.4116, 234.4622, 234.5428, 234.6528, 234.792, 234.9596, 235.1552, 235.3782, 235.6282, 235.9048, 236.207, 236.5344, 246.6466, 245.7954, 244.971, 244.1742, 243.4052, 242.6648, 241.9534, 241.2716, 240.6196, 239.9978, 239.4068, 238.8468, 238.3182, 237.8212, 237.356, 236.9228, 236.5218, 236.1534, 235.8172, 235.5136, 235.2424, 235.0036, 234.7972, 234.6232, 234.4812, 234.371, 234.2926, 234.2456, 234.2296, 234.2444, 234.2898, 234.365, 234.4698, 234.6036, 234.766, 234.9568, 235.175, 235.4202, 235.692, 235.9896, 236.3126, 246.681, 245.825, 244.996, 244.1942, 243.4204, 242.675, 241.9586, 241.2714, 240.6142, 239.9872, 239.3908, 238.8254, 238.2912, 237.7886, 237.318, 236.8792, 236.4726, 236.0984, 235.7566, 235.4474, 235.1704, 234.9262, 234.7142, 234.5344, 234.3868, 234.2712, 234.1872, 234.1348, 234.1134, 234.123, 234.163, 234.233, 234.3326, 234.4614, 234.619, 234.8048, 235.0182, 235.2588, 235.526, 235.8192, 236.138, 246.756, 245.8956, 245.0618, 244.2554, 243.477, 242.7268, 242.0054, 241.3134, 240.651, 240.0188, 239.4172, 238.8466, 238.3072, 237.7992, 237.323, 236.879, 236.467, 236.0872, 235.74, 235.4252, 235.1428, 234.893, 234.6756, 234.4904, 234.3374, 234.2164, 234.1272, 234.0694, 234.0428, 234.0472, 234.082, 234.147, 234.2416, 234.3656, 234.5184, 234.6994, 234.9082, 235.1442, 235.407, 235.6958, 236.0102, 246.8714, 246.0068, 245.1688, 244.3578, 243.5748, 242.8198, 242.0938, 241.397, 240.7298, 240.0926, 239.486, 238.9104, 238.3658, 237.8526, 237.3714, 236.922, 236.5048, 236.1198, 235.7672, 235.4472, 235.1596, 234.9044, 234.6816, 234.4912, 234.333, 234.2068, 234.1124, 234.0494, 234.0178, 234.017, 234.047, 234.107, 234.197, 234.3162, 234.4642, 234.6406, 234.845, 235.0766, 235.335, 235.6196, 235.93, 247.0274, 246.1586, 245.3162, 244.5012, 243.7136, 242.9544, 242.2236, 241.5222, 240.8504, 240.2084, 239.597, 239.0164, 238.467, 237.949, 237.4626, 237.0082, 236.586, 236.1958, 235.8382, 235.513, 235.2204, 234.96, 234.7322, 234.5368, 234.3734, 234.2422, 234.1428, 234.075, 234.0384, 234.0328, 234.058, 234.1132, 234.1984, 234.313, 234.4566, 234.6286, 234.8286, 235.056, 235.3102, 235.5906, 235.897, 247.2234, 246.3506, 245.5044, 244.6852, 243.8934, 243.1298, 242.3948, 241.689, 241.0126, 240.3662, 239.7502, 239.165, 238.6108, 238.088, 237.5968, 237.1376, 236.7104, 236.3154, 235.953, 235.6228, 235.3252, 235.06, 234.8272, 234.627, 234.4588, 234.3226, 234.2184, 234.1458, 234.1046, 234.0944, 234.1148, 234.1656, 234.2462, 234.3564, 234.4956, 234.6634, 234.859, 235.0824, 235.3324, 235.609, 235.9114, 247.4596, 246.583, 245.7328, 244.9096, 244.114, 243.3464, 242.6072, 241.897, 241.2164, 240.5656, 239.9452, 239.3556, 238.7968, 238.2694, 237.7738, 237.3098, 236.878, 236.4784, 236.1112, 235.7764, 235.474, 235.2042, 234.9668, 234.7616, 234.5888, 234.4482, 234.3392, 234.262, 234.2162, 234.2016, 234.2176, 234.264, 234.3404, 234.4462, 234.5812, 234.7448, 234.9366, 235.1558, 235.402, 235.6748, 235.9734, 247.7354, 246.8552, 246.0014, 245.1746, 244.375, 243.6034, 242.8604, 242.1462, 241.4616, 240.8066, 240.182, 239.588, 239.025, 238.4934, 237.9932, 237.525, 237.0888, 236.6846, 236.313, 235.9736, 235.6668, 235.3924, 235.1506, 234.941, 234.7636, 234.6186, 234.5052, 234.4236, 234.3736, 234.3544, 234.3662, 234.4084, 234.4806, 234.5824, 234.7134, 234.873, 235.0608, 235.2764, 235.5188, 235.788, 236.083, 248.0508, 247.1672, 246.31, 245.4796, 244.6764, 243.9012, 243.1544, 242.4364, 241.7478, 241.089, 240.4604, 239.8624, 239.2952, 238.7594, 238.2552, 237.7828, 237.3422, 236.934, 236.558, 236.2144, 235.9032, 235.6246, 235.3784, 235.1646, 234.983, 234.8336, 234.7162, 234.6304, 234.5762, 234.553, 234.5608, 234.599, 234.6672, 234.765, 234.8922, 235.048, 235.2322, 235.444, 235.6828, 235.9484, 236.2402, 248.4054, 247.5186, 246.6582, 245.8244, 245.0178, 244.2392, 243.4888, 242.7672, 242.075, 241.4124, 240.78, 240.1782, 239.6072, 239.0676, 238.5594, 238.0828, 237.6384, 237.2262, 236.846, 236.4984, 236.1834, 235.9006, 235.6504, 235.4326, 235.247, 235.0934, 234.972, 234.8824, 234.824, 234.797, 234.801, 234.8352, 234.8998, 234.994, 235.1174, 235.2696, 235.4502, 235.6586, 235.8942, 236.1564, 236.4448, 248.799, 247.9094, 247.0458, 246.2088, 245.399, 244.617, 243.8634, 243.1384, 242.4428, 241.7768, 241.1408, 240.5354, 239.9608, 239.4174, 238.9056, 238.4254, 237.977, 237.561, 237.1772, 236.8258, 236.5068, 236.2202, 235.9662, 235.7444, 235.555, 235.3978, 235.2726, 235.1792, 235.1172, 235.0864, 235.0866, 235.1174, 235.1784, 235.269, 235.389, 235.5378, 235.715, 235.9202, 236.1524, 236.4116, 236.6968 ) dft <- data.table(\"x\" = x, \"y\" = y, \"Score\" = c) g <- ggplot2::ggplot() +   ggplot2::geom_point(data = dft, ggplot2::aes(     x = .data$x, y = .data$y,     color = .data$Score   ), size = 2) +   ggplot2::scale_fill_continuous(guide = ggplot2::guide_colourbar(title = \"-2*Log-Likelihood\")) +   ggplot2::xlab(\"Parameter 1\") +   ggplot2::ylab(\"Parameter 2\") +   ggplot2::ggtitle(\"-2*Log-Likelihood\") +   ggplot2::scale_colour_viridis_c() g x <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22) y <- c(-0.1, 0.9, 0.446528, 0.839821, 0.493552, 0.799313, 0.528609, 0.768118, 0.555872, 0.743827, 0.577191, 0.724839, 0.593904, 0.70996, 0.607026, 0.698284, 0.617337, 0.689114, 0.625445, 0.681907, 0.631822, 0.67624, 0.67624, -0.1, 0.9, 0.446528, 0.431696, 0.834161, 0.857333, 0.501858, 0.477865, 0.793264, 0.814217, 0.531039, 0.511871, 0.770217, 0.78877, 0.55277, 0.530413, 0.745479, 0.771659, 0.578773, 0.54938, 0.72037, 0.750178, 0.750178, -0.1, -0.0683777, -0.0236573, 0.0204036, 0.0631351, 0.104199, 0.143407, 0.180661, 0.215914, 0.249159, 0.280419, 0.309735, 0.337162, 0.362769, 0.386631, 0.408828, 0.429444, 0.448562, 0.466269, 0.482647, 0.497779, 0.511745, 0.511745, -0.1, 0.0999967, 0.299992, 0.49416, 0.672686, 0.818272, 0.912721, 0.951325, 0.943139, 0.900966, 0.836339, 0.759197, 0.678706, 0.6037, 0.542181, 0.50002, 0.479848, 0.481022, 0.500511, 0.53392, 0.576232, 0.622276, 0.622276) c <- c(\"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\")  df <- data.table(\"x\" = x, \"y\" = y, \"method\" = c)  g <- ggplot2::ggplot(df, ggplot2::aes(x = .data$x, y = .data$y, group = .data$method, color = .data$method)) +   ggplot2::geom_line(\"linewidth\" = 1.2) +   ggplot2::labs(x = \"Iteration\", y = \"First Parameter Value\") +   ggplot2::ggtitle(\"First Parameter Value Convergence\") g x <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22) y <- c(-0.1, 0.382267, 0.481728, 0.371577, 0.474396, 0.383262, 0.464408, 0.392812, 0.456452, 0.40023, 0.45019, 0.406007, 0.445259, 0.41052, 0.441374, 0.414052, 0.438314, 0.416821, 0.435902, 0.418993, 0.434002, 0.420699, 0.420699, -0.1, 0.382267, 0.481728, 0.461092, 0.353981, 0.381487, 0.499642, 0.486223, 0.365388, 0.35904, 0.467404, 0.490215, 0.404434, 0.37681, 0.439266, 0.459563, 0.412495, 0.405195, 0.44752, 0.445014, 0.399118, 0.404763, 0.404763, -0.1, -0.0683799, -0.0236649, 0.0193058, 0.0594837, 0.0964731, 0.130195, 0.160739, 0.188284, 0.213051, 0.235278, 0.255201, 0.273049, 0.289032, 0.303346, 0.316169, 0.327659, 0.337961, 0.347201, 0.355493, 0.36294, 0.36963, 0.36963, -0.1, 0.0999917, 0.299977, 0.469249, 0.559129, 0.571139, 0.537754, 0.485171, 0.434002, 0.399975, 0.38974, 0.400107, 0.422011, 0.444253, 0.456706, 0.453734, 0.435816, 0.40853, 0.380544, 0.36118, 0.357234, 0.370462, 0.370462) c <- c(\"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\")  df <- data.table(\"x\" = x, \"y\" = y, \"method\" = c)  g <- ggplot2::ggplot(df, ggplot2::aes(x = .data$x, y = .data$y, group = .data$method, color = .data$method)) +   ggplot2::geom_line(\"linewidth\" = 1.2) +   ggplot2::labs(x = \"Iteration\", y = \"Second Parameter Value\") +   ggplot2::ggtitle(\"Second Parameter Value Convergence\") g x <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22) y <- c(239.962, 234.592, 234.454, 234.362, 234.282, 234.226, 234.178, 234.144, 234.116, 234.094, 234.076, 234.062, 234.052, 234.044, 234.038, 234.032, 234.028, 234.026, 234.022, 234.02, 234.02, 234.018, 234.018, 239.962, 234.592, 234.454, 234.494, 234.362, 234.416, 234.284, 234.344, 234.226, 234.292, 234.174, 234.244, 234.142, 234.204, 234.112, 234.17, 234.092, 234.144, 234.072, 234.122, 234.06, 234.102, 234.102, 239.962, 239.438, 238.74, 238.104, 237.536, 237.036, 236.598, 236.22, 235.89, 235.608, 235.364, 235.156, 234.978, 234.826, 234.696, 234.586, 234.492, 234.414, 234.348, 234.292, 234.244, 234.206, 234.206, 239.962, 237.064, 235.166, 234.276, 234.118, 234.34, 234.642, 234.804, 234.766, 234.58, 234.334, 234.122, 234.018, 234.042, 234.142, 234.246, 234.298, 234.286, 234.23, 234.158, 234.09, 234.04, 234.04) c <- c(\"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"standard\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"momentum\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adadelta\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\", \"adam\")  df <- data.table(\"x\" = x, \"y\" = y, \"method\" = c)  g <- ggplot2::ggplot(df, ggplot2::aes(x = .data$x, y = .data$y, group = .data$method, color = .data$method)) +   ggplot2::geom_line(\"linewidth\" = 1.2) +   ggplot2::labs(x = \"Iteration\", y = \"Log-Likelihood Value\") +   ggplot2::ggtitle(\"Log-Likelihood Convergence\") g"},{"path":"/articles/Grad_Hess.html","id":"hyper-parameter-tuning-examples","dir":"Articles","previous_headings":"Use in Practice","what":"Hyper-parameter Tuning Examples","title":"Gradient and Hessian Approaches","text":"First brief comparison learning rates standard gradient descent method. analysis, gradient scale (-2,2) learning rate scale ~ 1/10 appropriate. gradient much larger learning rate need correspondingly decreased. learning rate high, estimate unstable oscillate. learning rate low estimate converge reasonable amount time.  Next momentum decay. momentum decay term helpful particular standard method overshoots solution. example standard method learning rate 0.1 issue overshooting solution, tested momentum method learning rate 0.2 induce oscillation. learning rate 0.0 standard gradient descent, increase momentum effect see faster convergence.  Finally epsilon offset used adadelta method. example offset low change parameter value per iteration near zero, increased algorithm converges faster estimate oscillates.","code":"x <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22) y <- c(-0.1, -0.0758866, -0.0524678, -0.0297801, -0.00784991, 0.0133049, 0.0336744, 0.053255, 0.0720488, 0.0900628, 0.107308, 0.123797, 0.139549, 0.154581, 0.168914, 0.18257, 0.195571, 0.207941, 0.219702, 0.230879, 0.241495, 0.251573, 0.251573, -0.1, 0.141134, 0.305602, 0.376672, 0.406159, 0.418355, 0.423402, 0.425492, 0.426358, 0.426717, 0.426865, 0.426927, 0.426952, 0.426963, 0.426967, 0.426969, 0.42697, 0.42697, 0.42697, 0.42697, -0.1, 0.382267, 0.481728, 0.371577, 0.474396, 0.383262, 0.464408, 0.392812, 0.456452, 0.40023, 0.45019, 0.406007, 0.445259, 0.41052, 0.441374, 0.414052, 0.438314, 0.416821, 0.435902, 0.418993, 0.434002, 0.420699, 0.420699, -0.1, 0.9, -0.1, 0.9, -0.1, 0.9, -0.1, 0.9, -0.1, 0.9, -0.1, 0.9, -0.1, 0.9, -0.1, 0.9, -0.1, 0.9, -0.1, 0.9, -0.1, 0.9, 0.9) c <- c(\"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.01\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.1\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\")  df <- data.table(\"x\" = x, \"y\" = y, \"LearningRate\" = c)  g <- ggplot2::ggplot(df, ggplot2::aes(x = .data$x, y = .data$y, group = .data$LearningRate, color = .data$LearningRate)) +   ggplot2::geom_line(\"linewidth\" = 1.2) +   ggplot2::labs(x = \"Iteration\", y = \"Second Parameter\") +   ggplot2::ggtitle(\"Second Parameter Convergence\") g x <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22) y <- c(-0.1, 0.382267, 0.481728, 0.371577, 0.474396, 0.383262, 0.464408, 0.392812, 0.456452, 0.40023, 0.45019, 0.406007, 0.445259, 0.41052, 0.441374, 0.414052, 0.438314, 0.416821, 0.435902, 0.418993, 0.434002, 0.420699, 0.420699, -0.1, 0.382267, 0.481728, 0.391469, 0.435244, 0.429155, 0.424804, 0.427892, 0.426568, 0.427082, 0.427015, 0.426915, 0.426992, 0.426967, 0.42697, 0.426971, 0.42697, 0.426971, 0.42697, 0.42697, 0.426971, 0.426971, -0.1, 0.382267, 0.481728, 0.421307, 0.389624, 0.442182, 0.445048, 0.414796, 0.420771, 0.433596, 0.427802, 0.424361, 0.427741, 0.42752, 0.426131, 0.427168, 0.427483, 0.426655, 0.426746, 0.427195, 0.427034, 0.426856, 0.426856) c <- c(\"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.2\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\", \"0.5\")  df <- data.table(\"x\" = x, \"y\" = y, \"MomentumDecay\" = c)  g <- ggplot2::ggplot(df, ggplot2::aes(x = .data$x, y = .data$y, group = .data$MomentumDecay, color = .data$MomentumDecay)) +   ggplot2::geom_line(\"linewidth\" = 1.2) +   ggplot2::labs(x = \"Iteration\", y = \"Second Parameter\") +   ggplot2::ggtitle(\"Second Parameter Convergence\") g x <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22) y <- c(-0.1, -0.0998946, -0.0997455, -0.0995686, -0.0993678, -0.0991457, -0.0989042, -0.0986448, -0.0983686, -0.0980766, -0.0977695, -0.0974482, -0.0971132, -0.096765, -0.0964041, -0.0960311, -0.0956462, -0.0952498, -0.0948422, -0.0944238, -0.0939948, -0.0935554, -0.0935554, -0.1, -0.0894592, -0.0745523, -0.0569106, -0.0369613, -0.0149815, 0.00881833, 0.0342662, 0.0612136, 0.0895258, 0.119075, 0.149732, 0.181361, 0.213808, 0.246885, 0.280336, 0.313768, 0.346445, 0.376444, 0.393247, 0.380437, 0.397974, 0.397974, -0.1, -0.0666699, -0.0195369, 0.0357806, 0.0976085, 0.164622, 0.235362, 0.307561, 0.375392, 0.39949, 0.393904, 0.42769, 0.416127, 0.448594, 0.412644, 0.445826, 0.410436, 0.445034, 0.409797, 0.444717, 0.409586, 0.444599, 0.444599, -0.1, 0.00530869, 0.154075, 0.317511, 0.438734, 0.311745, 0.479287, 0.359676, 0.509816, 0.380595, 0.519051, 0.390015, 0.516403, 0.39013, 0.51552, 0.389794, 0.484692, 0.374198, 0.483729, 0.372471, 0.483021, 0.372011, 0.372011) c <- c(\"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-8\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-4\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-3\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\", \"1e-2\")  df <- data.table(\"x\" = x, \"y\" = y, \"Epsilon\" = c)  g <- ggplot2::ggplot(df, ggplot2::aes(x = .data$x, y = .data$y, group = .data$Epsilon, color = .data$Epsilon)) +   ggplot2::geom_line(\"linewidth\" = 1.2) +   ggplot2::labs(x = \"Iteration\", y = \"Second Parameter\") +   ggplot2::ggtitle(\"Second Parameter Convergence\") g"},{"path":"/articles/Matched_Case_Control.html","id":"matched-case-control-modeling","dir":"Articles","previous_headings":"","what":"Matched Case-Control Modeling","title":"Matched Case-Control Logistic Regression","text":"One upcoming regression method Colossus matched case-control logistic regression. implementation ongoing, theory presented following section.","code":""},{"path":"/articles/Matched_Case_Control.html","id":"general-theory","dir":"Articles","previous_headings":"Matched Case-Control Modeling","what":"General Theory","title":"Matched Case-Control Logistic Regression","text":"Suppose matched case-control data divide data matched set. set mm cases nn records. denote relative risk individual ii set rir_i. can calculate probability case exposures conditional exposures set taking ratio product relative risks cases sum product relative risks every way selecting mm individuals nn risk. ∏imri∑c∈R(∏j=1mrcj)L=∑=1mlog(ri)−log(∑c∈R(∏j=1mrcj)) \\begin{aligned}     \\frac{\\prod_{}^{m} r_i}{\\sum_{c \\R} \\left ( \\prod_{j=1}^{m} r_{c_j} \\right )} \\\\     L = \\sum_{=1}^{m} log(r_i) - log \\left ( \\sum_{c \\R} \\left ( \\prod_{j=1}^{m} r_{c_j} \\right ) \\right ) \\end{aligned} Using methods presented Gail et al. (1981) can calculate combination n!/m!(n−m)!n!/m!(n-m)! ways select mm items manageable recursive formula B(m,n)B(m,n). B(m,n)=∑c∈R(∏j=1mrcj)B(m,n)=B(m,n−1)+rnB(m−1,n−1)B(m,n)={∑jnrjm=10m>n \\begin{aligned}     B(m, n) = \\sum_{c \\R} \\left ( \\prod_{j=1}^{m} r_{c_j} \\right ) \\\\     B(m,n) = B(m, n-1) + r_n B(m-1, n-1) \\\\     B(m,n) = \\begin{cases}      \\sum_{j}^{n} r_j & m = 1 \\\\      0                & m > n     \\end{cases} \\end{aligned} can directly solve first second derivatives recursive formula. ∂ri∂βμ=:riμ∂B(m,n)∂βμ=Bμ(m,n)=∑c∈R[(∑j=1mrcjμrcj)∏j=1mrcj]Bμ(m,n)=Bμ(m,n−1)+rnBμ(m−1,n−1)+rnμB(m−1,n−1)Bμ(m,n)={∑jnrjμm=10m>n \\begin{aligned}     \\frac{\\partial r_i}{\\partial \\beta_\\mu} =: r_{}^{\\mu} \\\\     \\frac{\\partial B(m,n)}{\\partial \\beta_\\mu} = B^{\\mu}(m, n) = \\sum_{c \\R} \\left [ \\left ( \\sum_{j=1}^{m} \\frac{r_{c_j}^{\\mu}}{r_{c_j}} \\right ) \\prod_{j=1}^{m} r_{c_j} \\right ] \\\\     B^{\\mu}(m,n) = B^{\\mu}(m, n-1) + r_n B^{\\mu}(m-1, n-1) + r_n^{\\mu} B(m-1, n-1) \\\\     B^{\\mu}(m,n) = \\begin{cases}      \\sum_{j}^{n} r_j^{\\mu} & m = 1 \\\\      0                & m > n     \\end{cases} \\end{aligned} ∂2ri∂βμ∂βν=:riμ,ν∂2B(m,n)∂βμ∂βν=Bμ,ν(m,n)=∑c∈R[(∑j=1mrcjμ,νrcj+(∑j=1mrcjμrcj)(∑j=1mrcjνrcj)−∑j=1mrcjμrcjrcjνrcj)∏j=1mrcj]Bμ,ν(m,n)=Bμ,ν(m,n−1)+rnμ,νB(m−1,n−1)+rnνBμ(m−1,n−1)+rnμBν(m−1,n−1)+rnBμ,ν(m−1,n−1)Bμ,ν(m,n)={∑jnrjμ,νm=10m>n \\begin{aligned}     \\frac{\\partial^2 r_i}{\\partial \\beta_\\mu \\partial \\beta_\\nu} =: r_{}^{\\mu,\\nu} \\\\     \\frac{\\partial^2 B(m,n)}{\\partial \\beta_\\mu \\partial \\beta_\\nu} = B^{\\mu,\\nu}(m, n) = \\sum_{c \\R} \\left [ \\left ( \\sum_{j=1}^{m} \\frac{r_{c_j}^{\\mu,\\nu}}{r_{c_j}} +      \\left ( \\sum_{j=1}^{m} \\frac{r_{c_j}^{\\mu}}{r_{c_j}} \\right ) \\left ( \\sum_{j=1}^{m} \\frac{r_{c_j}^{\\nu}}{r_{c_j}} \\right ) - \\sum_{j=1}^{m} \\frac{r_{c_j}^{\\mu}}{r_{c_j}} \\frac{r_{c_j}^{\\nu}}{r_{c_j}} \\right ) \\prod_{j=1}^{m} r_{c_j} \\right ] \\\\     B^{\\mu,\\nu}(m,n) = B^{\\mu,\\nu}(m, n-1) + r_n^{\\mu,\\nu} B(m-1, n-1) + r_n^{\\nu} B^{\\mu}(m-1, n-1) + r_n^{\\mu} B^{\\nu}(m-1, n-1) + r_n B^{\\mu,\\nu}(m-1, n-1) \\\\     B^{\\mu,\\nu}(m,n) = \\begin{cases}      \\sum_{j}^{n} r_j^{\\mu,\\nu} & m = 1 \\\\      0                & m > n     \\end{cases} \\end{aligned} Finally expressions B(m,n)B(m,n) can substituted equations contribution Log-Likelihood ’s derivatives matched set. model optimized via methods regression models. Lset=∑=1mlog(ri)−log(B(m,n))Lsetμ=∑=1mriμri−Bμ(m,n)B(m,n)Lsetμ,ν=∑=1m(riμ,νri−riμririnuri)−(Bμ,ν(m,n)B(m,n)−Bμ(m,n)B(m,n)Bν(m,n)B(m,n)) \\begin{aligned}     L_{set} = \\sum_{=1}^{m} log(r_i) - log \\left ( B(m,n) \\right ) \\\\     L^{\\mu}_{set} = \\sum_{=1}^{m} \\frac{r_i^{\\mu}}{r_i} - \\frac{B^{\\mu}(m,n)}{B(m,n)} \\\\     L^{\\mu, \\nu}_{set} = \\sum_{=1}^{m} \\left ( \\frac{r_i^{\\mu,\\nu}}{r_i} - \\frac{r_i^{\\mu}}{r_i}\\frac{r_i^{nu}}{r_i} \\right ) - \\left ( \\frac{B^{\\mu,\\nu}(m,n)}{B(m,n)} - \\frac{B^{\\mu}(m,n)}{B(m,n)}\\frac{B^{\\nu}(m,n)}{B(m,n)}  \\right ) \\end{aligned}","code":""},{"path":"/articles/Multi_Realization.html","id":"available-methods","dir":"Articles","previous_headings":"","what":"Available Methods","title":"Multiple Realization Methods","text":"many instances user may want use data known distribution, cases may sufficient use single realization. Colossus provides two ways use multiple realizations. first runs multiple regressions row, different realization. second optimizes average Log-Likelihood realizations. method designed assist circumstances combinations shared unshared error present, two-dimensional Monte Carlo method used generate realizations least one covariate column. Note method apply event/cases interval/duration columns.","code":""},{"path":"/articles/Multi_Realization.html","id":"specifics-of-use","dir":"Articles","previous_headings":"Available Methods","what":"Specifics of Use","title":"Multiple Realization Methods","text":"Let us suppose interested performing regression three covariates: age bin, amount exposure radioisotope interval, average sleep interval. Age bin known, exposure known distribution shared among individuals, sleep randomly distributed independent interval. λ(,r,s)=exp(βa×+βa×r+βa×s) \\begin{aligned}     \\lambda(, r, s) = \\exp{(\\beta_a \\times + \\beta_a \\times r + \\beta_a \\times s)} \\end{aligned} Colossus requires two items apply multiple realizations, list columns replace matrix columns realization. Suppose user generates 5 realizations. two distributed columns five realizations. first method runs regression returns matrices final parameter estimates, standard deviations, final log-likelihoods regression. results can used create likelihood-weighted parameter distributions, account uncertainty final parameter estimates. second method returns standard regression output, using average log-likelihood. Note strict requirement realization columns actually realizations distributed column. user use method compare models formula different covariates. difficulty Colossus refresh parameter estimates realization regressions, user may need keep mind feasible parameter space. event individual realizations optimized initial parameter estimate infeasible, parameter estimates associated negative term reduced magnitude. cases enough find nearby feasible space start .","code":"names <- c(\"a\", \"r\", \"s\") term_n <- c(0, 0, 0) tform <- c(\"loglin\", \"loglin\", \"loglin\") modelform <- \"M\" fir <- 0  a_n <- c(0.1, 0.1, 0.1) model_control <- list(\"mcml\" = FALSE) # setting to true uses the Monte-Carlo Maximum Likelihood option and optimizes the average log-likelihood, setting to false optimizes each realization seperately. dose_index <- c(\"r\", \"s\") # the two columns in the model to replace are the radiation and sleeping covariates dose_realizations <- matrix(   c(\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"s0\", \"s1\", \"s2\", \"s3\", \"s4\"),   nrow = 2 ) # columns to be used for realizations 0-4, rows for each column being replaced"},{"path":"/articles/Plotting_And_Analysis.html","id":"example-setup","dir":"Articles","previous_headings":"","what":"Example Setup","title":"Functions for Plotting and Analysis","text":"use analysis lung dataset survival package visualize different plotting methods available Colossus.","code":"data(cancer, package = \"survival\")  df <- cancer df$UserID <- seq_len(nrow(df))  df$status <- df$status - 1 df$sex <- df$sex - 1  t0 <- \"%trunc%\" t1 <- \"time\" event <- \"status\"  names <- c(\"age\", \"sex\") tform <- c(\"loglin\", \"loglin\") control <- list(\"Ncores\" = 1, \"maxiter\" = 2, \"verbose\" = 0)  a_n <- c(0.01701289, -0.51256478) term_n <- c(0, 0) keep_constant <- c(0, 0) modelform <- \"M\" fir <- 0"},{"path":"/articles/Plotting_And_Analysis.html","id":"survival-function-approximation","dir":"Articles","previous_headings":"","what":"Survival Function Approximation","title":"Functions for Plotting and Analysis","text":"fitting Cox proportional hazards model, one may interested baseline survival rate . One method weighting number events event time total risk. absence excess risk hazard point time equal event rate hazard ratio every row equal one, assumption holds case negligible excess risk. λ(t)=d[t]n[t]=d[t]∑=1n(1)=d[t]∑=1n(ri) \\begin{aligned}     \\lambda(t) = \\frac{d[t]}{n[t]} = \\frac{d[t]}{\\sum_{=1}^n(1)} = \\frac{d[t]}{\\sum_{=1}^n(r_i)} \\end{aligned} Suppose every row risk time twice likely experience event baseline. expect twice many events baseline. logic applies case every row risk half likely. generalizes average risk. Colossus allows instantaneous hazard approximated stratified non-stratified models. λ(t)=d[t]∑=1n(ri)=d[t]∑=1n(2)=d[t]/2n[t]λ(t)=d[t]∑=1n(ri)=d[t]∑=1n(0.5)=d[t]*2n[t] \\begin{aligned}      \\lambda(t) = \\frac{d[t]}{\\sum_{=1}^n(r_i)} = \\frac{d[t]}{\\sum_{=1}^n(2)} = \\frac{d[t]/2}{n[t]}\\\\      \\lambda(t) = \\frac{d[t]}{\\sum_{=1}^n(r_i)} = \\frac{d[t]}{\\sum_{=1}^n(0.5)} = \\frac{d[t]*2}{n[t]} \\end{aligned} instantaneous hazard approximated, cumulative hazard can approximated. surviving fraction approximately equal exponential negative cumulative hazard event time. Λ(t)=∫0t(λ(x)dx)S(t)=exp(−Λ(t)) \\begin{aligned}     \\Lambda(t) = \\int_0^t (\\lambda(x) dx)\\\\     S(t) = \\exp{(-\\Lambda(t))} \\end{aligned}","code":"plot_options <- list(   \"type\" = c(\"surv\", paste(tempfile(), \"run\", sep = \"\")), \"studyid\" = \"UserID\",   \"verbose\" = 0, \"surv_curv\" = T, \"martingale\" = F, \"strat_haz\" = F, \"km\" = F )  e <- RunCoxPlots(   df, t0, t1, event, names, term_n, tform, keep_constant, a_n, modelform,   control = control, plot_options = plot_options )  norm_surv <- e[[\"standard\"]]  g <- ggplot2::ggplot(norm_surv, ggplot2::aes(x = .data$t, y = .data$h)) +   ggplot2::geom_point(color = \"black\") +   ggplot2::labs(x = \"age\", y = \"Instantaneous Hazard\") g g <- ggplot2::ggplot(norm_surv, ggplot2::aes(x = .data$t, y = .data$ch)) +   ggplot2::geom_line(color = \"black\", alpha = 1) +   ggplot2::labs(x = \"age\", y = \"Cumulative Hazard\") g g <- ggplot2::ggplot(norm_surv, ggplot2::aes(x = .data$t, y = .data$surv)) +   ggplot2::geom_line(color = \"black\", alpha = 1) +   ggplot2::labs(x = \"age\", y = \"Surviving Fraction\") g plot_options <- list(   \"type\" = c(\"surv\", paste(tempfile(), \"run\", sep = \"\")), \"studyid\" = \"UserID\",   \"verbose\" = 0, \"surv_curv\" = F, \"martingale\" = F, \"strat_haz\" = F, \"km\" = T )  e <- RunCoxPlots(   df, t0, t1, event, names, term_n, tform, keep_constant, a_n, modelform,   control = control, plot_options = plot_options ) km <- e[[\"kaplin-meier\"]] g <- ggplot2::ggplot(km, ggplot2::aes(x = .data$t_t, y = .data$n_t)) +   ggplot2::geom_line(color = \"black\", alpha = 1) +   ggplot2::labs(x = \"age\", y = \"KM Survival\") g"},{"path":"/articles/Plotting_And_Analysis.html","id":"cox-proportional-hazards-model-assumptions","dir":"Articles","previous_headings":"","what":"Cox Proportional Hazards model assumptions","title":"Functions for Plotting and Analysis","text":"Cox proportional hazards model definition assumes proportional hazards independent time. violated, results regression may misleading. two functions Colossus provides can used test assumption, Schoenfeld residuals Martingale residuals. cases premise hazard ratio independent time, residuals also independent time.","code":""},{"path":"/articles/Plotting_And_Analysis.html","id":"schoenfeld-residuals","dir":"Articles","previous_headings":"Cox Proportional Hazards model assumptions","what":"Schoenfeld Residuals","title":"Functions for Plotting and Analysis","text":"Schoenfeld residuals compare average covariate value rows events risk weighted average covariate rows risk. Consistently high low residuals may due hazard much higher lower model predicts. residuals also correlated event time, hazard ratio may dependent event time. also option scale residuals standard-deviation. s(t,x)=∑∈eventsxid[t]−∑inxi*ri∑inri \\begin{aligned}     s(t,x) = \\frac{\\sum_{\\events} x_i}{d[t]} - \\frac{\\sum_i^n x_i*r_i}{\\sum_i^n r_i} \\end{aligned}","code":"plot_options <- list(   \"type\" = c(\"schoenfeld\", paste(tempfile(), \"run\", sep = \"\")),   \"studyid\" = \"UserID\", \"verbose\" = 0 )  res_all <- RunCoxPlots(   df, t0, t1, event, names, term_n, tform, keep_constant, a_n,   modelform,   control = control, plot_options = plot_options )  res_age <- res_all[[\"age\"]]  g <- ggplot2::ggplot(res_age, ggplot2::aes(x = .data$time, y = .data$y)) +   ggplot2::geom_point(color = \"black\") +   ggplot2::labs(     x = paste(\"Survival Time\", sep = \"\"),     y = paste(\"Schoenfeld Residual (age)\", sep = \" \")   ) g g <- ggplot2::ggplot(res_age, ggplot2::aes(x = .data$time, y = .data$y_scale)) +   ggplot2::geom_point(color = \"black\") +   ggplot2::labs(     x = paste(\"Survival Time\", sep = \"\"),     y = paste(\"Schoenfeld Residual Scaled (age)\", sep = \" \")   ) g res_sex <- res_all[[\"sex\"]]  g <- ggplot2::ggplot(res_sex, ggplot2::aes(x = .data$time, y = .data$y)) +   ggplot2::geom_point(color = \"black\") +   ggplot2::labs(     x = paste(\"Survival Time\", sep = \"\"),     y = paste(\"Schoenfeld Residual (sex)\", sep = \" \")   ) g g <- ggplot2::ggplot(res_sex, ggplot2::aes(x = .data$time, y = .data$y_scale)) +   ggplot2::geom_point(color = \"black\") +   ggplot2::labs(     x = paste(\"Survival Time\", sep = \"\"),     y = paste(\"Schoenfeld Residual Scaled (sex)\", sep = \" \")   ) g"},{"path":"/articles/Plotting_And_Analysis.html","id":"martingale-residuals","dir":"Articles","previous_headings":"Cox Proportional Hazards model assumptions","what":"Martingale Residuals","title":"Functions for Plotting and Analysis","text":"Martingale residuals compare event status cumulative hazard subject. residual bound open interval (−∞,1)(-\\infty, 1). Negative residuals correspond subjects survive despite high cumulative hazard residuals near unity correspond subject experienced event despite low cumulative hazard. distribution residuals event time can indicate model -predicting -predicting dependent time. mj=δj−∫t0t1λ(t)*rjdt \\begin{aligned}     m_j = \\delta_j - \\int_{t_0}^{t_1} \\lambda(t) * r_j dt \\end{aligned}","code":"plot_options <- list(   \"type\" = c(\"surv\", paste(tempfile(), \"run\", sep = \"\")),   \"studyid\" = \"UserID\", \"verbose\" = 0, \"surv_curv\" = F,   \"martingale\" = T, \"strat_haz\" = F, \"km\" = F, \"cov_cols\" = c(\"age\", \"sex\") ) res_all <- RunCoxPlots(   df, t0, t1, event, names, term_n, tform, keep_constant, a_n,   modelform,   control = control, plot_options = plot_options )  res_age <- res_all[[\"age\"]]  g <- ggplot2::ggplot() +   ggplot2::geom_point(     data = res_age,     ggplot2::aes(x = .data$cov_max, y = .data$res_sum, group = .data$event, color = .data$event)   ) g <- g + ggplot2::labs(x = \"Max Age\", y = \"Martingale Residuals\") g res_sex <- res_all[[\"sex\"]] g <- ggplot2::ggplot() +   ggplot2::geom_point(     data = res_sex,     ggplot2::aes(x = .data$cov_max, y = .data$res_sum, group = .data$event, color = .data$event)   ) g <- g + ggplot2::labs(x = \"Sex\", y = \"Martingale Residuals\") g res_surv <- res_all[[\"survival_time\"]] g <- ggplot2::ggplot() +   ggplot2::geom_point(     data = res_surv,     ggplot2::aes(x = .data$time_max, y = .data$res_sum, group = .data$event, color = .data$event)   ) g <- g + ggplot2::labs(x = \"Survival Time\", y = \"Martingale Residuals\") g"},{"path":"/articles/Plotting_And_Analysis.html","id":"general-evaluation-of-risk","dir":"Articles","previous_headings":"","what":"General Evaluation of Risk","title":"Functions for Plotting and Analysis","text":"Colossus also offers scripts plot relative risk parameter value parameter model, assuming every parameter constant. parameter 10 values assumed constant.","code":"plot_options <- list(   \"type\" = c(\"risk\", paste(tempfile(), \"run\", sep = \"\")), \"studyid\" = \"UserID\",   \"verbose\" = 0 ) res_all <- RunCoxPlots(   df, t0, t1, event, names, term_n, tform, keep_constant, a_n,   modelform,   control = control, plot_options = plot_options )  res_age <- res_all[[\"age\"]]  g <- ggplot2::ggplot(res_age, ggplot2::aes(x = .data$x, y = .data$y)) +   ggplot2::geom_line(color = \"black\") +   ggplot2::labs(x = \"Age\", y = \"Relative Risk\") g res_sex <- res_all[[\"sex\"]] g <- ggplot2::ggplot(res_sex, ggplot2::aes(x = .data$x, y = .data$y)) +   ggplot2::geom_point(color = \"black\") +   ggplot2::labs(x = \"Sex\", y = \"Relative Risk\") g"},{"path":"/articles/SMR_Analysis.html","id":"external-rate-comparisons","dir":"Articles","previous_headings":"","what":"External Rate Comparisons","title":"SMR Analysis","text":"times important determine event rate cohort statistically different event rate reference population. traditionally done calculating Standardized Mortality Ratio (SMR). analysis assumes researcher table event rates different combinations ages categories reference population, applied collected data estimate number events collected data subject background event rate reference population. goal generally determine observed events statistically different expected number events, investigate much effect difference covariate .","code":""},{"path":"/articles/SMR_Analysis.html","id":"smr-calculation","dir":"Articles","previous_headings":"External Rate Comparisons","what":"SMR Calculation","title":"SMR Analysis","text":"One method approximate fit model SMR. simplest model estimate true rate (λi\\lambda_i) multiple expected rate (λi*\\lambda^{*}_{}). provides SMR full cohort, assuming one estimated rate every row data. λi=β*λi* \\begin{aligned}     \\lambda_i = \\beta * \\lambda^{*}_{} \\end{aligned} analysis use veteran lung cancer trial data survival package. treat events status equal 2, scale survival time per 100 days, assume every row expected event rate 0.5, roughly double average rate data. practice constant population average row specific rate taken mapping table external events onto data. analysis proceeds identically standard Poisson regression. interested linear relationship expected event rate true event rate, set initial parameter estimate 1. case found SMR 0.474, analysis confidence interval (either Wald Likelihood-based) performed check results statistically significant. Lets suppose wanted take analysis step investigate effect difference covariates. SMR equation can adjusted either additive multiplicative effect, similar Poisson regression model. Let us assume interested effects biological sex. can add another element model rerun regression. Let us start holding constant multiple (β0\\beta_0) constant 1 investigate difference SMR entirely due biological sex. λi=β0*λi**(1+β1*x0,) \\begin{aligned}     \\lambda_i = \\beta_0 * \\lambda^{*}_{} *( 1 + \\beta_1 * x_{0,}) \\end{aligned} case estimated contribution biological sex 0, find effect biological sex difference SMR. Suppose let parameter free investigated combined effects. run regression, time neither parameter held constant. case found SMR sex=0 0.37 SMR sex=1 0.56. investigate confidence intervals determine estimates statistically significant, however demonstrates one can use Poisson regressions external event rates estimate differences event rates external populations studied populations.","code":"data(cancer, package = \"survival\")  cancer$status <- as.integer(cancer$status == 2) cancer$time <- cancer$time / 100  cancer$erate <- 0.5 pyr <- \"time\" event <- \"status\" names <- c(\"erate\") term_n <- c(0) tform <- c(\"lin\") keep_constant <- c(0) a_n <- c(1) modelform <- \"M\" fir <- 0 der_iden <- 0 control <- list(   \"ncores\" = 1, \"maxiter\" = 20, \"halfmax\" = 5, \"epsilon\" = 1e-9,   \"deriv_epsilon\" = 1e-9, \"verbose\" = 1 ) e <- RunPoissonRegression_Omnibus(   cancer, pyr, event, names, term_n, tform,   keep_constant, a_n, modelform, fir, der_iden, control )  print(e$beta_0) #> [1] 0.4741856 names <- c(\"erate\", \"sex\") term_n <- c(0, 1) tform <- c(\"lin\", \"lin\") keep_constant <- c(1, 0) a_n <- c(1, 1) e <- RunPoissonRegression_Omnibus(   cancer, pyr, event, names, term_n, tform,   keep_constant, a_n, modelform,   control = control ) print(e$beta_0) #> [1] 1 0 names <- c(\"erate\", \"sex\") term_n <- c(0, 1) tform <- c(\"lin\", \"lin\") keep_constant <- c(0, 0) a_n <- c(1, 1)  e <- RunPoissonRegression_Omnibus(   cancer, pyr, event, names, term_n, tform,   keep_constant, a_n, modelform,   control = control )  print(e$beta_0) #> [1] 0.3696187 0.1904852"},{"path":"/articles/Script_Comparison_Epicure.html","id":"introduction-to-colossus","dir":"Articles","previous_headings":"","what":"Introduction to Colossus","title":"Script comparisons with 32-bit Epicure","text":"Colossus developed context radiation epidemiologists wanting use new methods data. time development, 32-bit Epicure popular software running radiation epidemiological analysis. vignette written mind help transitioning users see two similar different, addition providing guidance converting two. script provided discuss Colossus-specific differences well general R capabilities differ Epicure.","code":""},{"path":"/articles/Script_Comparison_Epicure.html","id":"example-epicure-analysis","dir":"Articles","previous_headings":"Introduction to Colossus","what":"Example Epicure Analysis","title":"Script comparisons with 32-bit Epicure","text":"following peanuts script used part validation efforts Colossus. script runs three regressions. linear excess relative risk model, log-linear hazard ratio model dose overall, log-linear hazard ratio model categorical bins dose. script starts loading dataset. example assume file called “EX_DOSE.csv” local directory. Next script sets interval start column, interval end column, designates columns multiple levels. Past point script specifies columns belong subterm term number. case model linear element second term. script additionally sets convergence options. case maximum iterations set 100 convergence criteria set 1e-9. regression also set print deviance parameter estimate iteration, print final estimates covariance regression concludes. Finally regression run results printed console. Past point general process followed two hazard ratio regressions. model definition reset, subterm/term description set, regression run.","code":"RECORDS 4100000 @ WSOPT VARMAX 30 @ USETXT EX_DOSE.csv @ INPUT @ ENTRY age_entry @ EXIT age_exit @ EVENT nonCLL @  levels SES_CAT YOB_CAT sexm dose_cat @ LOGLINEAR 0 SES_CAT YOB_CAT sexm @ LINEAR 1 cumulative_dose @  FITOPT P V ITER 100 CONV -9 @ FIT @ NOMODEL @  LOGLINEAR 0 SES_CAT YOB_CAT sexm cumulative_dose @  FIT @  NOMODEL @  LOGLINEAR 0 SES_CAT YOB_CAT sexm dose_cat @  FIT @  NOMODEL @"},{"path":"/articles/Script_Comparison_Epicure.html","id":"colossus-script","dir":"Articles","previous_headings":"Introduction to Colossus","what":"Colossus Script","title":"Script comparisons with 32-bit Epicure","text":"part, steps performed Colossus. script starts reading input file. difference R require memory set aside prior reading file. next step defines covariates levels assigns interval/event column information. main difference Colossus currently automatically split factored columns. first several lines transform dataset include factored columns, later user list factored columns. Next script defines model control information. Colossus stores model information like columns table. expects lists column names, subterm types, term numbers, etc. case non-default values column names subterm types. “control” variable serves similar purpose “FITOPT” option Epicure. Finally regression run, list results returned variable “e”. similar process run two hazard ratio regressions.","code":"df_Dose <- fread(\"EX_DOSE.csv\") col_list <- c(\"SES_CAT\", \"YOB_CAT\", \"dose_cat\") val <- factorize(df_Dose, col_list) df_Dose <- val$df  t0 <- \"age_entry\" t1 <- \"age_exit\" event <- \"nonCLL\" # ERR names <- c(   \"cumulative_dose\", \"SES_CAT_1\", \"SES_CAT_2\", \"YOB_CAT_1\", \"YOB_CAT_2\",   \"YOB_CAT_3\", \"YOB_CAT_4\", \"sexm\" ) tform <- c(\"plin\", rep(\"loglin\", length(names) - 1)) control <- list(\"Ncores\" = 8, \"maxiter\" = 50, \"verbose\" = F) e <- RunCoxRegression(df_Dose, t0, t1, event, names, tform = tform, control = control) # HR names <- c(   \"cumulative_dose\", \"SES_CAT_1\", \"SES_CAT_2\", \"YOB_CAT_1\", \"YOB_CAT_2\",   \"YOB_CAT_3\", \"YOB_CAT_4\", \"sexm\" ) tform <- rep(\"loglin\", length(names)) e <- RunCoxRegression(df_Dose, t0, t1, event, names, tform = tform, control = control)  # Categorical names <- c(   \"dose_cat_1\", \"dose_cat_2\", \"dose_cat_3\", \"dose_cat_4\", \"dose_cat_5\",   \"dose_cat_6\", \"SES_CAT_1\", \"SES_CAT_2\", \"YOB_CAT_1\", \"YOB_CAT_2\",   \"YOB_CAT_3\", \"YOB_CAT_4\", \"sexm\" ) tform <- rep(\"loglin\", length(names)) e <- RunCoxRegression(df_Dose, t0, t1, event, names, tform = tform, control = control)"},{"path":[]},{"path":"/articles/Starting-Description.html","id":"model-structure","dir":"Articles","previous_headings":"","what":"Model Structure","title":"Colossus Description","text":"full potential, Colossus able analyze vast number possible risk/rate models. Specifically Colossus designed allow combination linear non-linear models estimate cox proportional hazard ratios, Poisson model rates, Fine-Gray Competing risks ratios. simplest exponential model. simplest model generally used hazard ratios survival analysis exponential linear function covariates. R(β→,x→)=exp(β→⋅x→) \\begin{aligned}     R(\\vec{\\beta},\\vec{x})=\\exp(\\vec{\\beta} \\cdot \\vec{x}) \\end{aligned} Colossus, general model extended abstracting sum product terms subterms. vignette, value calculated quantify risk event denoted risk, R, however exact meaning differs. Cox proportional hazard modeling, risk calculated hazard ratio. Poisson modeling risk calculated estimated number events per person-year. risk (RR) set formula dependent terms (TT). term formula dependent product subterms (SS). subterm function single covariate (xx) several parameters (α,β\\alpha,\\beta). currently five types risk models available. risk can expressed additive model (RAR_A), product additive model (RPAR_{PA}), Product additive excess model (RPAER_{PAE}), multiplicative excess model (RMR_M), geometric mixture model relative risks excess risks (RGMIXR_{GMIX}). RA=∑=0nTiRPA=T0×∑=1nTiRPAE=T0×(1+∑=1nTi)RM=T0×∏=1n(1+Ti)RGMIX=T0×(∏=1n(Ti*))θ×(1+∑=1n(Ti*−1))1−θTi*={TiRelative RiskTi+1Excess Risk \\begin{aligned}     R_{} &= \\sum_{=0}^n T_i\\\\     R_{PA} &= T_0 \\times \\sum_{=1}^n T_i\\\\     R_{PAE} &= T_0 \\times (1 + \\sum_{=1}^n T_i)\\\\     R_{M} &= T_0 \\times \\prod_{=1}^n( 1 + T_i)\\\\     R_{GMIX} &= T_0 \\times \\left(\\prod_{=1}^n(T^{*}_i) \\right) ^ \\theta \\times \\left( 1 + \\sum_{=1}^n (T^{*}_i - 1) \\right)^{1-\\theta}\\\\     T^{*}_i &= \\begin{cases} T_i &\\text{Relative Risk} \\\\ T_i+1 &\\text{Excess Risk} \\end{cases}\\\\ \\end{aligned} term composed combination 4 types subterms. Every covariate part log-linear subterm, linear subterm, product-linear subterm, general non-linear term. log-linear subterm (SLLS_{LL}) exponential linear combination covariates. linear subterm (SLS_L) linear combination covariates. product-linear subterm (SPLS_{PL}) one plus linear combination covariates. general non-linear term (SNLS_{NL}) sum exponential terms, quadratic terms, linear-threshold terms (FLTF_{LT}), step function terms (FSTPF_{STP}), linear-quadratic terms (FLQF_{LQ}), linear-exponential terms (FLEXPF_{LEXP}). term product non-empty subterms. SLL=∏(exp(xi⋅βi))SL=∑(xi⋅βi)SPL=1+∑(xi⋅βi)SNL=∑(αi×exp(xi⋅βi))+∑(βi⋅(xi)2)+∑iFLT+∑iFSTP+∑iFLQ+∑iFLEXPFLT={αi⋅(x−βi)(x>βi)0elseFSTP={αi(x>βi)0elseFLQ={βi⋅x(x>αi)λi⋅x2+νielseFLEXP={βi⋅x(x>αi)λi−exp(νi+μ⋅x)elseTj=SLL,j×SL,j×SPL,j×SNL,j \\begin{aligned}     S_{LL}&=\\prod_{} (\\exp{(x_i \\cdot \\beta_i)})\\\\     S_{L}&=\\sum_i (x_i \\cdot \\beta_i)\\\\     S_{PL}&=1+ \\sum (x_i \\cdot \\beta_i)\\\\     S_{NL}&=\\sum_i (\\alpha_i \\times \\exp(x_i \\cdot \\beta_i)) + \\sum_i (\\beta_i \\cdot (x_i)^2)\\\\     & + \\sum_i F_{LT} + \\sum_i F_{STP} + \\sum_i F_{LQ} + \\sum_i F_{LEXP}\\\\     F_{LT} &= \\begin{cases} \\alpha_i \\cdot (x-\\beta_i) & (x>\\beta_i) \\\\ 0 &\\text{else} \\end{cases}\\\\     F_{STP} &= \\begin{cases} \\alpha_i & (x>\\beta_i) \\\\ 0 &\\text{else} \\end{cases}\\\\     F_{LQ} &= \\begin{cases} \\beta_i \\cdot x & (x>\\alpha_i) \\\\ \\lambda_i \\cdot x^2 + \\nu_i &\\text{else} \\end{cases}\\\\     F_{LEXP} &= \\begin{cases} \\beta_i \\cdot x & (x>\\alpha_i) \\\\ \\lambda_i - \\exp{(\\nu_i + \\mu \\cdot x)} &\\text{else} \\end{cases}\\\\     T_j&=S_{LL,j} \\times S_{L,j} \\times S_{PL,j} \\times S_{NL,j} \\end{aligned} short, every element risk model subterm type, term number, covariate, parameter value.","code":""},{"path":"/articles/Starting-Description.html","id":"using-the-standard-model","dir":"Articles","previous_headings":"","what":"Using The Standard Model","title":"Colossus Description","text":"Colossus every equation defined similar fashion. user side code, elements risk equation can viewed rows table. columns store covariate names, term numbers, subterms types, starting point. complex regression parameters can also set remain constant regression. forces parameter value remain constant remove element risk calculations. Constant elements used risk calculation, used calculating steps standard deviations. multiplicative excess risk model following table equation equivalent. R=exp(βa⋅xa)×(1+βb⋅xb+βc⋅xc) \\begin{aligned}     R = \\exp{(\\beta_{} \\cdot x_{})} \\times (1+\\beta_{b} \\cdot x_{b} + \\beta_{c} \\cdot x_{c}) \\end{aligned} user wanted update model include new term product-linear subterm, table need updated new row. R=exp(βa⋅xa)×(1+(βb⋅xb+βc⋅xc))×(2+βd⋅xd) \\begin{aligned}     R = \\exp{(\\beta_{} \\cdot x_{})} \\times (1 + (\\beta_{b} \\cdot x_{b} + \\beta_{c} \\cdot x_{c})) \\times (2 + \\beta_{d} \\cdot x_{d}) \\end{aligned} Note multiplicative model taking product terms, product subterms. equation may written subterms distributed different terms multiplicative model without changing final value. exception subterms moved “first” term multiplicative excess model. equation expressed ways different computational complexity. specific model options passed code separate variables. model identifier (, M, PA, PAE, GMIX) passed string. Every model except additive model distinction first remaining terms. Colossus defaults term 0 unique term, however can set used term number without producing error. final table also equivalent following code names denotes column names used, term_n denotes term numbers, tform denotes subterm formula, modelform denotes term formula, fir denotes “first” term indexed zero defaults 0, a_n denotes initial guesses parameter values. assumed order. function called prior regression reorders inputs order terms, subterm types, etc.","code":"names <- c(\"a\", \"b\", \"c\", \"d\") term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0  a_n <- c(0.1, 0.1, 0.1, 0.1)"},{"path":"/articles/Starting-Description.html","id":"survival-time-and-event-data","dir":"Articles","previous_headings":"","what":"Survival Time and Event Data","title":"Colossus Description","text":"Colossus performs survival analysis via either Cox Proportional Hazards Poisson model regression. cases user specifies columns contain time duration events interest. Poisson model regression column contains person-years number events row data. Cox Proportional Hazards regression user identifies columns provide starting ending times, column gives event status. event status assumed binary covariate 1 intervals containing event. Colossus supports left censored data, right censored data, interval censored data. data interval censored default, left right censoring handled defining interval endpoints outside minimum maximum event times. Poisson model regression user provides columns person-years per row number events. Poisson model regression supports non-negative number events. user side, names columns containing time events need given. Lets assume dataframe organized follows: Cox Proportional Hazard need provide three column names: starting age, ending age, event happened interval. case “Starting_Age”, “Ending_Age”, “Cancer_Status”. example interval data, however may always case. Colossus designed allow user input “%trunc%” -place missing side interval. Colossus assumes means person missing endpoint outside available data range creates dummy column reference interval endpoint. code variables look like : Suppose instead interested Poisson model regression, difference instead providing interval endpoints give column interval lengths. case need define new column, may case general. Suppose now working following table: just provide duration column event column, “Person_Years” “Cancer_Status”. code looks like following:","code":"df <- data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\"  # Supposing we had left truncated data the following would change time1 <- \"Starting_Age\" time2 <- \"%trunc%\"  # and with right truncated data the following is used time1 <- \"%trunc%\" time2 <- \"Ending_Age\"  # setting back to normal time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" df$Person_Years <- df$Ending_Age - df$Starting_Age pyr <- \"Person_Years\" event <- \"Cancer_Status\""},{"path":"/articles/Starting-Description.html","id":"control-and-verbosity","dir":"Articles","previous_headings":"","what":"Control and Verbosity","title":"Colossus Description","text":"Colossus offers several options control input data used returned. can split two general categories. first category convergence parameters. cover number iterations used, limits parameter changes, stopping criteria. second category parameters used debugging additional information. common option verbosity. verbose mode prints time-steps intermediate values sum terms, sum risks, log-likelihood iteration. less common option der_iden parameter, used change one parameter time set amount. used debugging process recording intermediate values plane. option used user conjunction verbose option plot intermediate values parameter value. convergence parameters currently supported general follows: additional information parameters currently supported follows: previous options contained within list parameters, however additional standalone parameters control convergence information. follows: Going back example, code may look like following: example, parameters held constant, 100 iterations 5 half-steps used, regression performed matrix step solutions, breslow’s method tied event times used. errors unused control parameters used, simply ignored. Every commonly required control parameter default value automatically used declared. includes optional list model control options. used nonstandard model options covered vignette.","code":"keep_constant <- c(0, 0, 0, 0) der_iden <- 0  control <- list(   \"ncores\" = 1, \"lr\" = 0.75, \"maxiter\" = 100, \"halfmax\" = 5, \"epsilon\" = 1e-3,   \"dbeta_max\" = 0.5, \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE, \"ties\" = \"breslow\", \"double_step\" = 1 )"},{"path":"/articles/Starting-Description.html","id":"running-the-regression-and-output","dir":"Articles","previous_headings":"","what":"Running the Regression and Output","title":"Colossus Description","text":"Finally user calls regression function need. names used throughout vignette defaults assumed. Cox PH regression Poisson model regression called directly return list results. Colossus contains suite additional checks runs inputs prior starting calculations, designed output explicit details issues. Printing error details may require verbose option TRUE. code functions called follows: following output: cases, regressions converge. Given examples arbitrary unexpected. Cox PH ran iterations decrease step limit, restarted new optimal guess expected continue converging. Poisson model regression exited due step limit threshold, means hit local optimum. find better solution user likely either change model equation provide new starting guess. example interpret results Colossus run. additional variants functions described outside section. return similar list results.","code":"# assuming the table of covariates is stored in a data.table \"df\"  e <- RunCoxRegression(   df, time1, time2, event, names, term_n, tform, keep_constant,   a_n, modelform, fir, der_iden, control ) Interpret_Output(e) #> |-------------------------------------------------------------------| #> Final Results #>    Covariate Subterm Term Number Central Estimate Standard Deviation #>       <char>  <char>       <int>            <num>              <num> #> 1:         a  loglin           0         40.29492                NaN #> 2:         b     lin           1         40.72266          3322.3606 #> 3:         c     lin           1         38.82311           628.5925 #> 4:         d    plin           2         43.10000           588.7424 #>  #> Cox Model Used #> -2*Log-Likelihood: 1.4,  AIC: 9.4 #> Iterations run: 42 #> maximum step size: 1.00e+00, maximum first derivative: 9.82e-04 #> Analysis converged #> Run finished in 0.06 seconds #> |-------------------------------------------------------------------|  # or a Poisson model regression a_n <- c(0.1, 0.1, 0.1, 0.1) # a_n is updated when either regression is called e <- RunPoissonRegression(   df, pyr, event, names, term_n, tform, keep_constant, a_n,   modelform,   control = control ) Interpret_Output(e) #> |-------------------------------------------------------------------| #> Final Results #>    Covariate Subterm Term Number Central Estimate Standard Deviation #>       <char>  <char>       <int>            <num>              <num> #> 1:         a  loglin           0      -0.40680015        0.381634898 #> 2:         b     lin           1      -0.01846667        0.035174231 #> 3:         c     lin           1      -0.07585910        0.007685371 #> 4:         d    plin           2      -0.70133825        0.405384920 #>  #> Poisson Model Used #> -2*Log-Likelihood: 89.48,  Deviation: 85.48,  AIC: 93.48,  BIC: 97.26 #> Iterations run: 8 #> maximum step size: 3.05e-05, maximum first derivative: 2.31e+03 #> Analysis did not converge, check convergence criteria or run further #> Run finished in 0.05 seconds #> |-------------------------------------------------------------------|"},{"path":"/articles/Time_Dep_Cov.html","id":"general-usage","dir":"Articles","previous_headings":"","what":"General Usage","title":"Time Dependent Covariate Use","text":"Cox Proportional Hazards regression, model generally assumed independent event time. However complex models, Colossus capability perform regression using covariates change time. can split two general types covariates, step functions changing time multiplicative interactions time. Colossus generates new dataset splitting row original dataset smaller intervals. assumes interval values every covariate approximately constant. Cox Proportional Hazards, rows contain event time used regression, Colossus option use small intervals around event time. option time dependent covariate evaluated event times. data-sets small number discrete event times can save memory.","code":""},{"path":"/articles/Time_Dep_Cov.html","id":"multiplicative-interaction","dir":"Articles","previous_headings":"","what":"Multiplicative Interaction","title":"Time Dependent Covariate Use","text":"simplest type time dependent covariate interaction term time another covariate. Suppose row dataset factor covariate “group” arbitrary endpoints time interval. Colossus starts using user provided function calculate value time dependent covariate endpoints. assume value “group” constant interval time changing linearly. Colossus calculates value time dependent covariate intervals linearly interpolating value endpoints. process assumes interaction linear interval small enough interaction approximately linear. Linear Interpolated Function Y(x)=x2+1 \\begin{aligned}     Y(x)=x^2 + 1 \\end{aligned} helpful situation user continuous data series intervals believes values can interpolated within interval.","code":"dft <- data.table(\"x\" = c(1, 2, 3), \"y\" = c(2, 5, 10)) g <- ggplot2::ggplot(dft, ggplot2::aes(x = .data$x, y = .data$y)) +   ggplot2::geom_point(color = \"black\") +   ggplot2::geom_line(color = \"black\", alpha = 1) +   ggplot2::labs(x = \"age (days)\", y = \"Covariate Value\") x <- seq(1, 3, by = 0.1) y <- 1 + x^2 dft <- data.table(\"x\" = x, \"y\" = y) g <- g + ggplot2::geom_line(   data = dft, ggplot2::aes(x = .data$x, y = .data$y),   color = \"black\", linetype = \"dashed\" ) g"},{"path":"/articles/Time_Dep_Cov.html","id":"step-function-interaction","dir":"Articles","previous_headings":"","what":"Step Function Interaction","title":"Time Dependent Covariate Use","text":"second type time dependent covariate one changes based conditional statements. One example covariate split data bins time. Colossus uses string identify change value. user inputs string form “#l?” time value “#”, condition “l”, question mark delimiter. Colossus allows four conditions: l: less equal g: greater equal : strictly b: strictly following equivalent “0g?6g?12g?0g?6g?12g?” Monotonic Step Function Applied Y(x)={0(x<0)1(x≥0)2(x≥6)3(x≥12) \\begin{aligned}     Y(x)=\\begin{cases} 0 &(x < 0) \\\\ 1 & (x \\ge 0) \\\\ 2 &(x \\ge 6) \\\\ 3 &(x \\ge 12) \\end{cases}\\\\ \\end{aligned} Meanwhile following equivalent “0g?6g?12l?0g?6g?12l?” Step Function Applied Y(x)={1(x<0)2(x≥0)3(x≥6)2(x≥12) \\begin{aligned}     Y(x)=\\begin{cases} 1 &(x < 0) \\\\ 2 & (x \\ge 0) \\\\ 3 &(x \\ge 6) \\\\ 2 &(x \\ge 12) \\end{cases}\\\\ \\end{aligned} helpful situations user reason believe effect covariate events uniform time despite covariate constant interval. allows user generate list factors interact covariate interest.","code":"dft <- data.table(\"x\" = c(-1, 1, 5, 8, 13), \"y\" = c(0, 1, 1, 2, 3)) g <- ggplot2::ggplot(dft, ggplot2::aes(x = .data$x, y = .data$y)) +   ggplot2::geom_point(color = \"black\") dft <- data.table(\"x\" = c(-1, -0.01, 0, 1, 5.99, 6, 11.99, 12, 13), \"y\" = c(0, 0, 1, 1, 1, 2, 2, 3, 3)) g <- g + ggplot2::geom_line(data = dft, ggplot2::aes(x = .data$x, y = .data$y), color = \"black\") +   ggplot2::labs(x = \"age (days)\", y = \"Covariate Value\") g dft <- data.table(\"x\" = c(-1, 1, 5, 8, 13), \"y\" = c(1, 2, 2, 3, 2)) g <- ggplot2::ggplot(dft, ggplot2::aes(x = .data$x, y = .data$y)) +   ggplot2::geom_point(color = \"black\") dft <- data.table(\"x\" = c(-1, -0.01, 0, 1, 5.99, 6, 11.99, 12, 13), \"y\" = c(1, 1, 2, 2, 2, 3, 3, 2, 2)) g <- g + ggplot2::geom_line(data = dft, ggplot2::aes(x = .data$x, y = .data$y), color = \"black\") +   ggplot2::labs(x = \"age (days)\", y = \"Covariate Value\") g"},{"path":"/articles/Wald_and_Log_Bound.html","id":"available-methods","dir":"Articles","previous_headings":"","what":"Available Methods","title":"Confidence Interval Selection","text":"Colossus supports two methods calculating confidence interval model parameters Cox proportional hazards models. Wald method likelihood-based bound method. vignette focused differences issues may arise.","code":""},{"path":"/articles/Wald_and_Log_Bound.html","id":"wald-method","dir":"Articles","previous_headings":"Available Methods","what":"Wald Method","title":"Confidence Interval Selection","text":"Colossus finishes Cox regression, returns parameter estimates standard errors. simplest form confidence interval assuming normal distribution parameter mean deviation. standard errors calculated covariance matrix, calculated line equation expected information matrix presented 32-bit Epicure manual. covariance matrix calculated using inverse expected information matrix (II). derivation outlined end vignette clarity. every event time (ii) number events (did_i) list subjects risk (l∈Ril \\R_i). Every valid combination subject event time hazard ratio (rlir_{li}) derivative hazard ratio respect parameter (β\\beta). equation used compute covariance matrix standard errors returned Colossus default. Fine-Gray models use similar equation also weights contribution row risk, similar adjustments used calculate log-likelihood. (βμ,βν)=∑=1N(di*[∑l∈RicliμcliνrliEi−FiμFiνEi2])cliμ=bliμrli,bliμ=∂rli∂βμ,Ei=∑l∈Rirli,Fiμ=∑l∈Ribliμ \\begin{aligned}     (\\beta_\\mu, \\beta_\\nu) = \\sum_{=1}^{N} \\left ( d_i * \\left[ \\sum_{l \\R_i} \\frac{c_{li}^{\\mu} c_{li}^{\\nu} r_{li}}{E_i} - \\frac{F_i^{\\mu} F_i^{\\nu}}{E_i^2} \\right] \\right )\\\\     c_{li}^{\\mu} = \\frac{b_{li}^{\\mu}}{r_{li}}, \\quad b_{li}^{\\mu} = \\frac{\\partial r_{li}}{\\partial \\beta_{\\mu}}, \\quad E_{} = \\sum_{l \\R_i} r_{li}, \\quad F_i^{\\mu} = \\sum_{l \\R_i} b_{li}^{\\mu} \\end{aligned} gives symmetric parameter confidence interval often accurate single term log-linear models. However approximation often inaccurate models linear effects, particularly confidence interval includes negative values. Wald method approximates likelihood confidence interval, guarantee model defined interval.","code":""},{"path":"/articles/Wald_and_Log_Bound.html","id":"likelihood-based-bound","dir":"Articles","previous_headings":"Available Methods","what":"Likelihood-Based Bound","title":"Confidence Interval Selection","text":"exact solution directly solve boundary. basic premise model can optimized parameter (β\\beta) fixed. value β\\beta corresponding maximum log-likelihood. confidence interval range values β\\beta maximum log-likelihood threshold, taken asymptotic χ2\\chi^2 distribution generalized likelihood ratio test. Colossus uses Venzon-Moolgavkar algorithm iteratively solve interval endpoints. one main issues can arise method. algorithm uses Newton-Raphson algorithm, may solve local solutions instead global solution. Similar general Colossus regressions, limitations can placed step size limit effects. However, analogue selecting multiple starting locations. basis ongoing work code alternative can directly solve true optimum. method directly solves confidence interval, linear cases may non-symmetric even upper lower bounds. Linear models may defined parameter threshold. optimum value parameter threshold χ2\\chi^2 threshold value, interval lower bound.","code":""},{"path":"/articles/Wald_and_Log_Bound.html","id":"example-and-comparison","dir":"Articles","previous_headings":"Available Methods","what":"Example and Comparison","title":"Confidence Interval Selection","text":"sake comparison, consider analysis capacitor data available survival package. Consider two regressions, one fully exponential one linear effect. regressions converge nearly identical scores. Next suppose interested confidence intervals. Suppose want 95% confidence intervals Wald likelihood-based boundaries parameters model. Let us start fully exponential model. Wald boundary estimated using central estimates standard deviations. Likelihood boundary solved using “log_bound” option model control list. parameter number needs provided (indexed starting zero) alpha level needs provided. Overall likelihood boundary solved scores within narrow margin threshold. However boundaries exactly . boundaries temperature (-0.017, 1.537) (-0.01, 1.560), boundaries voltage (0.800, 3.177) (0.841, 3.242). two boundaries scale less 0.1. Next analyze model linear effect. expect predictions . boundaries temperature (-0.523, 2.800) (-0.010, 3.758), boundaries voltage (0.800, 3.177) (0.841, 3.242). estimates voltage boundary , estimates temperature boundary much .","code":"data(reliability, package = \"survival\")  df <- capacitor df$voltage <- (df$voltage - 200) / 150 df$temperature <- (df$temperature - 170) / 10 df$time <- (df$time - 216) / (1105 - 216)  t0 <- \"%trunc%\" t1 <- \"time\" event <- \"status\"  names <- c(\"temperature\", \"voltage\") tform <- c(\"loglin\", \"loglin\") control <- list(\"Ncores\" = 1, \"maxiter\" = 100, \"verbose\" = 0)  a_n <- c(0.01, 0.01) term_n <- c(0, 0) keep_constant <- c(0, 0) modelform <- \"M\"  e1 <- RunCoxRegression(   df, t0, t1, event, names, term_n, tform, keep_constant,   a_n, modelform,   control = control ) Interpret_Output(e1, 5) #> |-------------------------------------------------------------------| #> Final Results #>      Covariate Subterm Term Number Central Estimate Standard Deviation #>         <char>  <char>       <int>            <num>              <num> #> 1: temperature  loglin           0        0.7599511          0.3964440 #> 2:     voltage  loglin           0        1.9884051          0.6063097 #>  #> Cox Model Used #> -2*Log-Likelihood: 210.77792,  AIC: 214.77792 #> Iterations run: 9 #> maximum step size: 1.00000e+00, maximum first derivative: 1.30641e-05 #> Analysis converged #> Run finished in 0.06501 seconds #> |-------------------------------------------------------------------|  names <- c(\"temperature\", \"voltage\") tform <- c(\"plin\", \"loglin\") a_n <- c(0.01, 0.01)  e2 <- RunCoxRegression(   df, t0, t1, event, names, term_n, tform, keep_constant,   a_n, modelform,   control = control ) Interpret_Output(e2, 5) #> |-------------------------------------------------------------------| #> Final Results #>      Covariate Subterm Term Number Central Estimate Standard Deviation #>         <char>  <char>       <int>            <num>              <num> #> 1: temperature    plin           0         1.138152          0.8476570 #> 2:     voltage  loglin           0         1.988403          0.6063096 #>  #> Cox Model Used #> -2*Log-Likelihood: 210.77792,  AIC: 214.77792 #> Iterations run: 9 #> maximum step size: 1.00000e+00, maximum first derivative: 2.89872e-05 #> Analysis converged #> Run finished in 0.05523 seconds #> |-------------------------------------------------------------------| names <- c(\"temperature\", \"voltage\") tform <- c(\"loglin\", \"loglin\") ci_1 <- c(   e1$beta_0[1] - 1.96 * e1$Standard_Deviation[1],   e1$beta_0[1] + 1.96 * e1$Standard_Deviation[1] ) ci_2 <- c(   e1$beta_0[2] - 1.96 * e1$Standard_Deviation[2],   e1$beta_0[2] + 1.96 * e1$Standard_Deviation[2] )  a_n <- c(0.7599511, 1.9884051) term_n <- c(0, 0) keep_constant <- c(0, 0) modelform <- \"M\"  model_control <- list(   \"basic\" = FALSE, \"maxstep\" = 100,   \"log_bound\" = TRUE, \"alpha\" = 0.05,   \"para_number\" = 0, \"manual\" = TRUE ) e <- RunCoxRegression_Omnibus(df, t0, t1, event, names,   term_n = term_n,   tform = tform, keep_constant = keep_constant,   a_n = a_n, modelform = modelform,   control = control, model_control = model_control ) print(\"|------------------- Wald Estimate -------------------|\") #> [1] \"|------------------- Wald Estimate -------------------|\" print(ci_1) #> [1] -0.01707914  1.53698136 Interpret_Output(e, 5) #> |-------------------------------------------------------------------| #> Likelihood Boundary Results #> Lower limit converged to at -0.0099 at a score of -107.30968 with of goal of -107.30969 #> Upper limit converged to at 1.55991 at a score of -107.30968 with of goal of -107.30969 #> Run finished in 0.06005 seconds #> |-------------------------------------------------------------------|  a_n <- c(0.7599511, 1.9884051) model_control <- list(   \"basic\" = FALSE, \"maxstep\" = 100,   \"log_bound\" = TRUE, \"alpha\" = 0.05,   \"para_number\" = 1, \"manual\" = TRUE ) e <- RunCoxRegression_Omnibus(df, t0, t1, event, names,   term_n = term_n,   tform = tform, keep_constant = keep_constant,   a_n = a_n, modelform = modelform,   control = control, model_control = model_control ) print(\"|------------------- Likelihood Bound Estimate -------------------|\") #> [1] \"|------------------- Likelihood Bound Estimate -------------------|\" print(ci_2) #> [1] 0.800038 3.176772 Interpret_Output(e, 5) #> |-------------------------------------------------------------------| #> Likelihood Boundary Results #> Lower limit converged to at 0.84124 at a score of -107.30968 with of goal of -107.30969 #> Upper limit converged to at 3.24203 at a score of -107.30968 with of goal of -107.30969 #> Run finished in 0.05954 seconds #> |-------------------------------------------------------------------| names <- c(\"temperature\", \"voltage\") tform <- c(\"plin\", \"loglin\") ci_1 <- c(   e2$beta_0[1] - 1.96 * e2$Standard_Deviation[1],   e2$beta_0[1] + 1.96 * e2$Standard_Deviation[1] ) ci_2 <- c(   e2$beta_0[2] - 1.96 * e2$Standard_Deviation[2],   e2$beta_0[2] + 1.96 * e2$Standard_Deviation[2] )  a_n <- c(1.138152, 1.988403) term_n <- c(0, 0) keep_constant <- c(0, 0) modelform <- \"M\"  model_control <- list(   \"basic\" = FALSE, \"maxstep\" = 100,   \"log_bound\" = TRUE, \"alpha\" = 0.05,   \"para_number\" = 0, \"manual\" = TRUE ) e <- RunCoxRegression_Omnibus(df, t0, t1, event, names,   term_n = term_n,   tform = tform, keep_constant = keep_constant,   a_n = a_n, modelform = modelform,   control = control, model_control = model_control ) print(\"|------------------- Wald Estimate -------------------|\") #> [1] \"|------------------- Wald Estimate -------------------|\" print(ci_1) #> [1] -0.5232557  2.7995597 Interpret_Output(e, 5) #> |-------------------------------------------------------------------| #> Likelihood Boundary Results #> Lower limit converged to at -0.00984 at a score of -107.30967 with of goal of -107.30969 #> Upper limit converged to at 3.75837 at a score of -107.30968 with of goal of -107.30969 #> Run finished in 0.05969 seconds #> |-------------------------------------------------------------------|  a_n <- c(1.138152, 1.988403) model_control <- list(   \"basic\" = FALSE, \"maxstep\" = 100,   \"log_bound\" = TRUE, \"alpha\" = 0.05,   \"para_number\" = 1, \"manual\" = TRUE ) e <- RunCoxRegression_Omnibus(df, t0, t1, event, names,   term_n = term_n,   tform = tform, keep_constant = keep_constant,   a_n = a_n, modelform = modelform,   control = control, model_control = model_control ) print(\"|------------------- Wald Estimate -------------------|\") #> [1] \"|------------------- Wald Estimate -------------------|\" print(ci_2) #> [1] 0.8000365 3.1767701 Interpret_Output(e, 5) #> |-------------------------------------------------------------------| #> Likelihood Boundary Results #> Lower limit converged to at 0.84124 at a score of -107.30968 with of goal of -107.30969 #> Upper limit converged to at 3.24203 at a score of -107.30968 with of goal of -107.30969 #> Run finished in 0.05963 seconds #> |-------------------------------------------------------------------|"},{"path":"/articles/Wald_and_Log_Bound.html","id":"illustration-of-issues-with-likelihood-boundary-algorithm","dir":"Articles","previous_headings":"Available Methods","what":"Illustration of Issues with Likelihood-Boundary Algorithm","title":"Confidence Interval Selection","text":"One important thing keep mind likelihood-based boundary algorithm perfect, times may important manually solve likelihood curve. following example outlines done details curve can cause issues boundary algorithm. following uses dataset used Colossus unit testing. linear parameter selected analysis. point grid, linear parameter fixed model optimized. important note two local optimums within small range (-0.6 global solution 1.4). algorithms used solving likelihood boundary, similar standard regression optimizing algorithm, trapped local optimums. means algorithm point cross local optimum, can trapped. two optimums close enough score 95% confidence interval lower boundary -0.5, 50% confidence interval lower bound -0.5 1.4. meant algorithm converged 50% confidence interval boundary, failed converge lower boundary 95% confidence interval boundary. Development ongoing automate process solving complete likelihood curve.","code":"fname <- \"base_example.csv\" df <- fread(fname)  time1 <- \"entry\" time2 <- \"exit\" event <- \"event\" names <- c(\"dose0\", \"dose1\", \"dose0\") term_n <- c(0, 0, 1) tform <- c(\"loglin\", \"loglin\", \"lin\") keep_constant <- c(0, 0, 1) a_n <- c(-1.493177, 5.020007, 1.438377) modelform <- \"M\" # model_control <- list() control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiters\" = c(100, 100), \"halfmax\" = 5,   \"epsilon\" = 1e-6, \"deriv_epsilon\" = 1e-6, \"abs_max\" = 1.0,   \"change_all\" = TRUE, \"dose_abs_max\" = 100.0, \"verbose\" = 0,   \"ties\" = \"breslow\", \"double_step\" = 1 )  v0 <- sort(c((0:50 / 50 - 1.0) * 0.8, 1:50 / 50 * 3, 1.438377, -0.5909)) for (v in v0) {   a_n <- c(-1.493177, 5.020007, v)   e <- RunCoxRegression_Omnibus(df, time1, time2, event, names,     term_n = term_n,     tform = tform, keep_constant = keep_constant, a_n = a_n,     modelform = modelform,     control = control, model_control = model_control   )   ll <- e$LogLik   beta <- e$beta_0   print(c(ll, beta[3])) } x <- c(-0.8, -0.784, -0.768, -0.752, -0.736, -0.72, -0.704, -0.688, -0.672, -0.656, -0.64, -0.624, -0.608, -0.592, -0.5909, -0.576, -0.56, -0.544, -0.528, -0.512, -0.496, -0.48, -0.464, -0.448, -0.432, -0.416, -0.4, -0.384, -0.368, -0.352, -0.336, -0.32, -0.304, -0.288, -0.272, -0.256, -0.24, -0.224, -0.208, -0.192, -0.176, -0.16, -0.144, -0.128, -0.112, -0.096, -0.08, -0.064, -0.048, -0.032, -0.016, 0.0, 0.06, 0.12, 0.18, 0.24, 0.3, 0.36, 0.42, 0.48, 0.54, 0.6, 0.66, 0.72, 0.78, 0.84, 0.9, 0.96, 1.02, 1.08, 1.14, 1.2, 1.26, 1.32, 1.38, 1.438377, 1.44, 1.5, 1.56, 1.62, 1.68, 1.74, 1.8, 1.86, 1.92, 1.98, 2.04, 2.1, 2.16, 2.22, 2.28, 2.34, 2.4, 2.46, 2.52, 2.58, 2.64, 2.7, 2.76, 2.82, 2.88, 2.94, 3.0) y <- c(-18500.53, -18499.829, -18499.273, -18498.831, -18498.482, -18498.21, -18497.995, -18497.832, -18497.71, -18497.621, -18497.56, -18497.519, -18497.498, -18497.49, -18497.4904, -18497.495, -18497.51, -18497.53, -18497.558, -18497.589, -18497.624, -18497.66, -18497.7, -18497.739, -18497.779, -18497.818, -18497.86, -18497.896, -18497.933, -18497.969, -18498.003, -18498.04, -18498.067, -18498.096, -18498.124, -18498.15, -18498.17, -18498.196, -18498.216, -18498.235, -18498.252, -18498.27, -18498.281, -18498.292, -18498.303, -18498.311, -18498.32, -18498.324, -18498.329, -18498.332, -18498.334, -18498.33, -18498.33, -18498.31, -18498.27, -18498.23, -18498.18, -18498.13, -18498.07, -18498.01, -18497.96, -18497.9, -18497.84, -18497.78, -18497.73, -18497.68, -18497.63, -18497.59, -18497.56, -18497.52, -18497.49, -18497.47, -18497.45, -18497.44, -18497.43, -18497.429487, -18497.43, -18497.43, -18497.44, -18497.45, -18497.47, -18497.5, -18497.52, -18497.56, -18497.6, -18497.64, -18497.69, -18497.74, -18497.8, -18497.86, -18497.93, -18498.0, -18498.07, -18498.15, -18498.23, -18498.32, -18498.41, -18498.5, -18498.6, -18498.7, -18498.81, -18498.92, -18499.03)  df <- data.table(\"x\" = x, \"y\" = y)  g <- ggplot2::ggplot(df, ggplot2::aes(x = .data$x, y = .data$y)) +   ggplot2::geom_line(color = \"black\", alpha = 1, \"linewidth\" = 1.5) +   ggplot2::labs(x = \"Linear Parameter Value\", y = \"Log-Likelihood\") +   ggplot2::ggtitle(\"Multi-Peak Curve\") g"},{"path":"/articles/Wald_and_Log_Bound.html","id":"likelihood-boundary-algorithm-alternative","dir":"Articles","previous_headings":"Available Methods","what":"Likelihood Boundary Algorithm Alternative","title":"Confidence Interval Selection","text":"alternative likelihood algorithm, direct curve solving method implemented. CoxCurveSolver function solves boundary values iteratively optimizing points using bisection method. step approximately fast running single regression. model_control options used select parameter selected alpha use, adds additional option “step_size” default search window width used. bisection method functions (1) selecting interval, (2) optimizing upper, lower, midpoint interval, (3) checking goal likelihood crossed. -least one interval points side goal interval narrowed, interval shifted away optimum. summary three functions available calculating likelihood based boundaries. first method standard Venzon-Moolgavkar algorithm. method attempts optimize model guide desired parameter boundary value. method fastest, susceptible local extrema. Using algorithm depends initial step close local extrema, initial step can scaled . second method modification Venzon-Moolgavkar algorithm. second method initial step split multiple guesses, guess optimized independently. Venzon-Moolgavkar algorithm continued closest guess exceed target likelihood. theory method makes likely algorithm start appropriate point, slower slightly less susceptible local extrema. However final portion algorithm still based derivatives, still susceptible local extrema. third method iterative bisection method. algorithm desired parameter fixed, model optimized endpoints interval interval located contains goal likelihood. interval split half interval width within user-set limit. method takes advantage fact likelihood curve continuous know optimum point must goal. algorithm split two steps: optimizing model fixed points determining interval contains goal. second step depend likelihood derivatives, prone getting stuck local extrema. However interval width must small enough step solution. Given small enough interval width, every optimization likely converge solution unlikely skipped. method requires model optimized repeatedly, expected take longest. However bisection method least likely issues converging.","code":"fname <- \"base_example.csv\" df <- fread(fname)  time1 <- \"entry\" time2 <- \"exit\" event <- \"event\" names <- c(\"dose0\", \"dose1\", \"dose0\") term_n <- c(0, 0, 1) tform <- c(\"loglin\", \"loglin\", \"lin\") keep_constant <- c(0, 0, 0) a_n <- c(-1.493177, 5.020007, 1.438377) modelform <- \"M\" # control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 100, \"halfmax\" = 5,   \"verbose\" = 0 )  model_control <- list(\"maxstep\" = 20, \"alpha\" = 0.005, \"para_number\" = 2, \"step_size\" = 0.5) e <- CoxCurveSolver(df, time1, time2, event, names,   term_n = term_n, tform = tform,   keep_constant = keep_constant, a_n = a_n, modelform = modelform,   control = control, model_control = model_control )"},{"path":"/articles/Wald_and_Log_Bound.html","id":"expected-information-matrix-derivation","dir":"Articles","previous_headings":"","what":"Expected Information Matrix Derivation","title":"Confidence Interval Selection","text":"expected information matrix calculated using two equations, second-derivative log-likelihood probability subject event given rows risk number events. begin, second derivative log-likelihood expressed follows: ∂2LL∂β→μ∂β→ν=∑=1N[δi([Ai,μ,ν−Bi,μ*Bi,ν]−[Ci,μ,ν−Di,μ*Di,ν])]Ai,μ,ν=∂2ri∂β→μ∂β→νri,Bi,μ=∂ri∂β→μriCi,μ,ν=∑l∈Ri∂2rl∂β→μ∂β→νEi,Di,μ=∑l∈Ri∂rl∂β→μEi,Ei=∑l∈Rirl \\begin{aligned}     \\frac{\\partial^2 LL}{\\partial \\vec{\\beta}_{\\mu} \\partial \\vec{\\beta}_{\\nu}} = \\sum_{=1}^N \\left[ \\delta_i \\left( [A_{,\\mu,\\nu} - B_{,\\mu}*B_{,\\nu} ] - [C_{,\\mu,\\nu} - D_{,\\mu}*D_{,\\nu} ]  \\right)\\right]\\\\     A_{,\\mu,\\nu} = \\frac{\\frac{\\partial^2 r_i}{\\partial \\vec{\\beta}_\\mu \\partial \\vec{\\beta}_\\nu}}{r_i}, \\quad B_{,\\mu} = \\frac{\\frac{\\partial r_i}{\\partial \\vec{\\beta}_\\mu}}{r_i} \\\\     C_{,\\mu,\\nu} = \\frac{\\sum_{l \\R_i} \\frac{\\partial^2 r_l}{\\partial \\vec{\\beta}_\\mu \\partial \\vec{\\beta}_\\nu}}{E_i},\\quad D_{,\\mu} = \\frac{\\sum_{l \\R_i} \\frac{\\partial r_l}{\\partial \\vec{\\beta}_\\mu}}{E_i}, \\quad E_{} = \\sum_{l \\R_i} r_l \\\\ \\end{aligned} Next assume independent failure censoring, dd events risk group RR. Assuming row risk approximately equal background rate, probability given subject event follows: pr(δi=1|d,R,β)=ri/∑l∈Rrl \\begin{aligned}     pr(\\delta_i = 1 | d,R, \\beta) = r_i / \\sum_{l \\R} r_l \\end{aligned} Finally want evaluate expected information matrix given following: (μ,ν)=E[−∂2LL∂β→μ∂β→ν] \\begin{aligned}     (\\mu, \\nu) = E \\left[-\\frac{\\partial^2 LL}{\\partial \\vec{\\beta}_{\\mu} \\partial \\vec{\\beta}_{\\nu}} \\right] \\end{aligned} can start splitting equation expected contribution event time (ii), simplifying expected value constant terms. Note switch event indicator row (δi\\delta_i) number events risk group (did_i): (μ,ν)=−E[∑k∈Ri(δk([Ai,μ,ν−Bi,μ*Bi,ν]−[Ci,μ,ν−Di,μ*Di,ν]))](μ,ν)=di*[Ci,μ,ν−Di,μ*Di,ν]−E[∑k∈Ri(δk([Ai,μ,ν−Bi,μ*Bi,ν]))]E[∑k∈RiδkAi,μ,ν]=∑l∈RiAl,μ,ν*pr(δl=1)=di*∑l∈Ri∂2rl∂β→μ∂β→νrl*rl∑l∈Rirl=di*Ci,μ,νE[Bi,μ*Bi,ν]=∑l∈RiBi,μ*Bi,ν*pr(δl=1)=di*∑l∈Riclμclνrl∑l∈Rirl \\begin{aligned}     (\\mu, \\nu)_i = - E \\left[ \\sum_{k \\R_i} \\left ( \\delta_k \\left( [A_{,\\mu,\\nu} - B_{,\\mu}*B_{,\\nu} ] - [C_{,\\mu,\\nu} - D_{,\\mu}*D_{,\\nu} ]  \\right) \\right )\\right] \\\\     (\\mu, \\nu)_i = d_i*[C_{,\\mu,\\nu} - D_{,\\mu}*D_{,\\nu} ] - E \\left [ \\sum_{k \\R_i} \\left ( \\delta_k \\left( [A_{,\\mu,\\nu} - B_{,\\mu}*B_{,\\nu} ] \\right ) \\right ) \\right] \\\\     E \\left [ \\sum_{k \\R_i} \\delta_k A_{,\\mu,\\nu} \\right] = \\sum_{l \\R_i} A_{l,\\mu,\\nu} * pr(\\delta_l = 1) = d_i * \\frac{\\sum_{l \\R_i} \\frac{\\frac{\\partial^2 r_l}{\\partial \\vec{\\beta}_\\mu \\partial \\vec{\\beta}_\\nu}}{r_l} * r_l}{ \\sum_{l \\R_i} r_l} = d_i * C_{,\\mu,\\nu}\\\\     E \\left [ B_{,\\mu}*B_{,\\nu} \\right] = \\sum_{l \\R_i} B_{,\\mu}*B_{,\\nu}*pr(\\delta_l = 1) = d_i * \\frac{\\sum_{l \\R_i} c_{l}^{\\mu}c_{l}^{\\nu}r_l}{\\sum_{l \\R_i} r_l} \\end{aligned} Finally substitute, cancel, use function definitions expected information matrix derived observed information matrix formula. (μ,ν)=di*[∑l∈RicliμcliνrliEi−FiμFiνEi2] \\begin{aligned}     (\\mu, \\nu)_i = d_i * \\left[ \\sum_{l \\R_i} \\frac{c_{li}^{\\mu} c_{li}^{\\nu} r_{li}}{E_i} - \\frac{F_i^{\\mu} F_i^{\\nu}}{E_i^2} \\right] \\end{aligned}","code":""},{"path":"/articles/count_time_tables.html","id":"general-purpose","dir":"Articles","previous_headings":"","what":"General Purpose","title":"Generating Person-Count and Person-Time Tables","text":"performing regression rate hazard ratio, often important look summary data. can informative break columns categories summarize number event average column value category. Colossus offers two function designed create summary tables, Event_Count_Gen Event_Time_Gen create person-count tables person-time table respectively. following sections cover generally use function different needs met.","code":""},{"path":"/articles/count_time_tables.html","id":"person-count-tables","dir":"Articles","previous_headings":"General Purpose","what":"Person-Count Tables","title":"Generating Person-Count and Person-Time Tables","text":"person count table simplest way summarize table. assumes columns want break categories columns want summarize. Lets start simple example. Suppose dataset tracking number apples oranges people bought, number hands used carry bag, bag ripped . Suppose want split dataset number fruit, count number ripped bags category, figure average number hands used. start defining want split categories. two general ways define intervals, single string list upper lower bounds. Lets start string representation. string expected alternate number delimiter, either / ], split upper lower bounds interval. Every interval format includes lower bound. interval includes upper bound ] used, otherwise. interval [2,5) equivalent “2/5” interval [5,8] equivalent “5]8”. method uses triplet sequentially, categories cover every value falls first last number listed. list notation similar. 2 values required list 1 optional value. list vectors titled lower upper, lower upper bounds interval. method can include gaps. Similarly string version, lower bound always included upper bound included upper bound entry includes ]. list option allows categories labeled instead automatically numbered. third list titled name can provided label category. Lets suppose want break apples column intervals: [0, 3), [3, 5), [5,7] break oranges column intervals: [-1,3), [3,6), [6,10) labels: , good, excessive. look like following code. splits category 3 levels, total 9 combinations. Now define summary variables want. , define list. Every item list named column applied contains string specifying summary method use. two options supported currently: count mean, sum mean column category. One can also provide new name summary column listing method “option name”. Otherwise grouped table use original column name summary column name. lets suppose wanted take sum ripped bags name “dropped” take mean hands column. final step run function. function returns two items, grouped data summary category intervals. category intervals checked verify intervals match expected.","code":"apples <- c(0, 1, 2, 3, 4, 5, 6, 2, 2, 3, 4, 2, 1, 5, 6, 4, 2) oranges <- c(1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1, 3, 2, 2, 1) rip <- c(0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1) hands <- c(1, 1, 2, 3, 2, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2) table <- data.table::data.table(   \"apples\" = apples,   \"oranges\" = oranges,   \"rip\" = rip,   \"hands\" = hands ) apple_category <- \"0/3/5]7\" orange_category <- list(   lower = c(-1, 3, 6),   upper = c(3, 6, 10),   name = c(\"few\", \"good\", \"excessive\") ) categ <- list(   \"apples\" = apple_category,   \"oranges\" = orange_category ) event <- list(\"rip\" = \"count AS dropped\", \"hands\" = \"mean\") Event_Count_Gen(table, categ, event) #> $df #>    apples_category oranges_category COUNT dropped hands #>             <char>           <char> <int>   <num> <num> #> 1:               1                1     8       3  1.50 #> 2:               2                2     5       3  2.00 #> 3:               3                3     4       3  1.25 #>  #> $bounds #> $bounds$apples_category #> [1] \" [0, 3) [3, 5) [5, 7]\" #>  #> $bounds$oranges_category #> [1] \" [-1, 3) [3, 6) [6, 10)\""},{"path":"/articles/count_time_tables.html","id":"person-time-tables","dir":"Articles","previous_headings":"General Purpose","what":"Person-Time Tables","title":"Generating Person-Count and Person-Time Tables","text":"previous method treats every row weighted . many cases every row measure time may want use. fundamental difference person count tables person time tables, inclusion time. code used generate person time table similar person count table, several important differences. first data time columns. Similar Cox model options Colossus, data entry column, exit column, . denote scenario every interval ends point, starts point, different start stopping times. method currently supports day/month/year information combined complete dates. Event_Time_Gen function uses list input time columns. list entry exit items needed, list column name year, month, day columns needed. dates default 1/1/1900 provided. person-year list can also contain unit, defaulted years. second major difference possible use time categories. Time categories set vectors day, month, year interval splitting point. intervals changing every 2 days expressed “day=c(1,3,5,…)”. Time categories unique row can correspond multiple time categories, duration row time category kept distinguish rows partially time interval. time category provided, full duration row used person-year calculations. final difference person-time tables make distinction events summaries. summary list nearly identical event list person-count function. difference weighted_mean option added. mean group weighted person-years. event list person-time table function used determine time categories event columns assigned . Based relative row intervals category intervals, row can part multiple time categories. However, event assigned time category containing endpoint row interval. Finally function run. Similar person-count table function, function returns grouped table list category boundaries.","code":"a <- c(0, 1, 2, 3, 4, 5, 6, 2, 2, 3, 4, 2, 1, 5, 6, 4, 2) b <- c(1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1, 3, 2, 2, 1) c <- c(0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1)  d <- c(1, 1, 2, 2, 1, 1, 2, 2, 3, 3, 3, 4, 4, 2, 1, 1, 2) e <- c(1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1) f <- c(   1900, 1900, 1900, 1900, 1900, 1900, 1900, 1900, 1900,   1900, 1900, 1900, 1900, 1900, 1900, 1900, 1900 ) g <- c(4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 5, 5, 5, 4, 4, 4, 4) h <- c(6, 4, 4, 6, 6, 6, 4, 4, 4, 6, 6, 6, 6, 4, 4, 4, 4) i <- c(   1901, 1902, 1903, 1904, 1905, 1906, 1907, 1903, 1904,   1903, 1904, 1910, 1903, 1904, 1903, 1904, 1910 ) table <- data.table::data.table(   \"a\" = a, \"b\" = b, \"c\" = c,   \"d\" = d, \"e\" = e, \"f\" = f,   \"g\" = g, \"h\" = h, \"i\" = i )  pyr <- list(   entry = list(year = \"f\", month = \"e\", day = \"d\"),   exit = list(year = \"i\", month = \"h\", day = \"g\"),   unit = \"years\" ) categ <- list(   \"a\" = \"-1/3/5]7\",   \"b\" = list(     lower = c(-1, 3, 6), upper = c(3, 6, 10),     name = c(\"low\", \"medium\", \"high\")   ),   \"time AS time_bin\" = list(     \"day\" = c(1, 1, 1),     \"month\" = c(1, 1, 1),     \"year\" = c(1899, 1903, 1910)   ) ) summary <- list(\"c\" = \"count AS cases\", \"b\" = \"weighted_mean AS b_weighted\") events <- list(\"c\") pyr <- list(   entry = list(year = \"f\", month = \"e\", day = \"d\"),   exit = list(year = \"i\", month = \"h\", day = \"g\"),   unit = \"years\" ) print(Event_Time_Gen(table, pyr, categ, summary, events, T)) #> $df #>     a_category b_category time_bin AT_RISK        PYR cases b_weighted #>         <char>     <char>   <char>   <int>      <num> <num>      <num> #>  1:          1       high        1       1  2.9952088     0   6.000000 #>  2:          1       high        2       1  0.2600958     0   6.000000 #>  3:          1        low        1       5 12.4791239     1   1.413339 #>  4:          1        low        2       3 14.4257358     0   1.485291 #>  5:          1     medium        1       2  5.9876797     0   3.999543 #>  6:          1     medium        2       2  1.5167693     1   4.664260 #>  7:          2        low        1       1  2.9979466     0   2.000000 #>  8:          2        low        2       1  1.2566735     0   2.000000 #>  9:          2     medium        1       4 11.8083504     0   3.993276 #> 10:          2     medium        2       4  5.7056810     3   4.175144 #> 11:          3       high        1       2  5.8234086     0   6.499765 #> 12:          3       high        2       2  7.6824093     2   6.554170 #> 13:          3        low        1       1  2.9130732     0   2.000000 #> 14:          3        low        2       1  0.2546201     1   2.000000 #> 15:          3     medium        1       1  2.9103354     0   3.000000 #> 16:          3     medium        2       1  1.2566735     0   3.000000 #>  #> $bounds #> $bounds$a_category #> [1] \" [-1, 3) [3, 5) [5, 7]\" #>  #> $bounds$b_category #> [1] \" [-1, 3) [3, 6) [6, 10)\" #>  #> $bounds$time_bin #> [1] \" [1899-01-01 to 1903-01-01] [1903-01-01 to 1910-01-01]\" pyr <- list(   entry = list(year = \"f\", month = \"e\", day = \"d\"),   exit = list(year = \"i\", month = \"h\", day = \"g\"),   unit = \"months\" ) print(Event_Time_Gen(table, pyr, categ, summary, events, T)) #> $df #>     a_category b_category time_bin AT_RISK        PYR cases b_weighted #>         <char>     <char>   <char>   <int>      <num> <num>      <num> #>  1:          1       high        1       1  35.942505     0   6.000000 #>  2:          1       high        2       1   3.121150     0   6.000000 #>  3:          1        low        1       5 149.749487     1   1.413339 #>  4:          1        low        2       3 173.108830     0   1.485291 #>  5:          1     medium        1       2  71.852156     0   3.999543 #>  6:          1     medium        2       2  18.201232     1   4.664260 #>  7:          2        low        1       1  35.975359     0   2.000000 #>  8:          2        low        2       1  15.080082     0   2.000000 #>  9:          2     medium        1       4 141.700205     0   3.993276 #> 10:          2     medium        2       4  68.468172     3   4.175144 #> 11:          3       high        1       2  69.880903     0   6.499765 #> 12:          3       high        2       2  92.188912     2   6.554170 #> 13:          3        low        1       1  34.956879     0   2.000000 #> 14:          3        low        2       1   3.055441     1   2.000000 #> 15:          3     medium        1       1  34.924025     0   3.000000 #> 16:          3     medium        2       1  15.080082     0   3.000000 #>  #> $bounds #> $bounds$a_category #> [1] \" [-1, 3) [3, 5) [5, 7]\" #>  #> $bounds$b_category #> [1] \" [-1, 3) [3, 6) [6, 10)\" #>  #> $bounds$time_bin #> [1] \" [1899-01-01 to 1903-01-01] [1903-01-01 to 1910-01-01]\" pyr <- list(   entry = list(year = \"f\", month = \"e\", day = \"d\"),   exit = list(year = \"i\", month = \"h\", day = \"g\"),   unit = \"days\" ) print(Event_Time_Gen(table, pyr, categ, summary, events, T)) #> $df #>     a_category b_category time_bin AT_RISK   PYR cases b_weighted #>         <char>     <char>   <char>   <int> <num> <num>      <num> #>  1:          1       high        1       1  1094     0   6.000000 #>  2:          1       high        2       1    95     0   6.000000 #>  3:          1        low        1       5  4558     1   1.413339 #>  4:          1        low        2       3  5269     0   1.485291 #>  5:          1     medium        1       2  2187     0   3.999543 #>  6:          1     medium        2       2   554     1   4.664260 #>  7:          2        low        1       1  1095     0   2.000000 #>  8:          2        low        2       1   459     0   2.000000 #>  9:          2     medium        1       4  4313     0   3.993276 #> 10:          2     medium        2       4  2084     3   4.175144 #> 11:          3       high        1       2  2127     0   6.499765 #> 12:          3       high        2       2  2806     2   6.554170 #> 13:          3        low        1       1  1064     0   2.000000 #> 14:          3        low        2       1    93     1   2.000000 #> 15:          3     medium        1       1  1063     0   3.000000 #> 16:          3     medium        2       1   459     0   3.000000 #>  #> $bounds #> $bounds$a_category #> [1] \" [-1, 3) [3, 5) [5, 7]\" #>  #> $bounds$b_category #> [1] \" [-1, 3) [3, 6) [6, 10)\" #>  #> $bounds$time_bin #> [1] \" [1899-01-01 to 1903-01-01] [1903-01-01 to 1910-01-01]\""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Eric Giunta. Author, maintainer. Amir Bahadori. Contributor. Dan Andresen. Contributor. Linda Walsh. Contributor. Benjamin French. Contributor. Lawrence Dauer. Contributor. John Boice Jr. Contributor. Kansas State University. Copyright holder. NASA. Funder. NCRP. Funder. NRC. Funder.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Giunta E, Bahadori , Andresen D, Walsh L, French B, Dauer L, Boice Jr J (2024). Colossus: Risk Model Regression Analysis Complex Non-Linear Models. https://github.com/ericgiunta/Colossus. Giunta E, Stutzman D, Cohen S, French B, Walsh L, Dauer L, Boice Jr J, Blattnig S, Andresen D, Bahadori (2024). “Colossus: Software radiation epidemiologic studies big data.” https://burkclients.com/IRPA/2024/site/welcome.html.","code":"@Manual{,   title = {Colossus: Risk Model Regression and Analysis with Complex Non-Linear Models},   author = {Eric Giunta and Amir Bahadori and Dan Andresen and Linda Walsh and Benjamin French and Lawrence Dauer and John {Boice Jr}},   year = {2024},   url = {https://github.com/ericgiunta/Colossus}, } @Misc{,   title = {Colossus: Software for radiation epidemiologic studies with big data},   author = {Eric Giunta and Dawson Stutzman and Sarah Cohen and Benjamin French and Linda Walsh and Lawrence Dauer and John {Boice Jr} and Steve Blattnig and Dan Andresen and Amir Bahadori},   year = {2024},   url = {https://burkclients.com/IRPA/2024/site/welcome.html},   publisher = {IRPA 16}, }"},{"path":"/index.html","id":"colossus","dir":"","previous_headings":"","what":"","title":"","text":"goal Colossus provide open-source means performing survival analysis big data complex risk formula. Colossus designed perform Cox Proportional Hazard regressions Poisson regressions datasets loaded data.tables data.frames. risk models allowed sums products linear, log-linear, several radiation dose response formula highlighted vignettes. Additional plotting capabilities available. default fully portable version code compiled, support OpenMP every system. Note Colossus requires OpenMP support perform parallel calculations. environment variable “R_COLOSSUS_NOT_CRAN” checked determine OpenMP disabled linux compiling clang. number cores set 1 environment variable empty, operating system detected linux, default compiler R compiler clang. Colossus testing checks “NOT_CRAN” variable determine additional tests run. Setting “NOT_CRAN” “false” disable longer tests. Currently OpenMP support configured linux compiling clang.","code":""},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"","text":"basic example shows solve common problem:","code":"library(data.table) library(parallel) library(Colossus) ## basic example code reproduced from the starting-description vignette  df <- data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\"  names <- c(\"a\", \"b\", \"c\", \"d\") term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\"  a_n <- c(0.1, 0.1, 0.1, 0.1)  keep_constant <- c(0, 0, 0, 0) der_iden <- 0  control <- list(   \"lr\" = 0.75, \"maxiter\" = 100, \"halfmax\" = 5, \"epsilon\" = 1e-9,   \"deriv_epsilon\" = 1e-9, \"abs_max\" = 1.0,   \"verbose\" = FALSE, \"ties\" = \"breslow\" )  e <- RunCoxRegression(df, time1, time2, event, names, term_n, tform, keep_constant, a_n, modelform, control = control) Interpret_Output(e) #> |-------------------------------------------------------------------| #> Final Results #>    Covariate Subterm Term Number Central Estimate Standard Deviation #>       <char>  <char>       <int>            <num>              <num> #> 1:         a  loglin           0         44.53340       9.490627e+07 #> 2:         b     lin           1         98.72266                NaN #> 3:         c     lin           1         96.82311       2.408255e+02 #> 4:         d    plin           2        101.10000       5.207003e+02 #>  #> Cox Model Used #> -2*Log-Likelihood: 1.35,  AIC: 9.35 #> Iterations run: 100 #> maximum step size: 1.00e+00, maximum first derivative: 1.92e-04 #> Analysis did not converge, check convergence criteria or run further #> Run finished in 0.25 seconds #> |-------------------------------------------------------------------|"},{"path":"/reference/Check_Dupe_Columns.html","id":null,"dir":"Reference","previous_headings":"","what":"checks for duplicated column names — Check_Dupe_Columns","title":"checks for duplicated column names — Check_Dupe_Columns","text":"Check_Dupe_Columns checks duplicated columns, columns values, columns single value. Currently updated multi-terms","code":""},{"path":"/reference/Check_Dupe_Columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"checks for duplicated column names — Check_Dupe_Columns","text":"","code":"Check_Dupe_Columns(df, cols, term_n, verbose = 0, factor_check = FALSE)"},{"path":"/reference/Check_Dupe_Columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"checks for duplicated column names — Check_Dupe_Columns","text":"df data.table containing columns interest cols columns check term_n term numbers element model verbose integer valued 0-4 controlling information printed terminal. level includes lower levels. 0: silent, 1: errors printed, 2: warnings printed, 3: notes printed, 4: debug information printed. Errors situations stop regression, warnings situations assume default values user might intended, notes provide information regression progress, debug prints C++ progress intermediate results. default level 2 True/False converted 3/0. factor_check boolean used skip comparing columns form ?_? initial string, used factored columns","code":""},{"path":"/reference/Check_Dupe_Columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"checks for duplicated column names — Check_Dupe_Columns","text":"returns usable columns","code":""},{"path":[]},{"path":"/reference/Check_Dupe_Columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"checks for duplicated column names — Check_Dupe_Columns","text":"","code":"library(data.table) a <- c(0, 1, 2, 3, 4, 5, 6) b <- c(1, 2, 3, 4, 5, 6, 7) c <- c(0, 1, 2, 1, 0, 1, 0) df <- data.table::data.table(\"a\" = a, \"b\" = b, \"c\" = c) cols <- c(\"a\", \"b\", \"c\") term_n <- c(0, 0, 1) unique_cols <- Check_Dupe_Columns(df, cols, term_n)"},{"path":"/reference/Check_Trunc.html","id":null,"dir":"Reference","previous_headings":"","what":"Applies time duration truncation limits to create columns for Cox model — Check_Trunc","title":"Applies time duration truncation limits to create columns for Cox model — Check_Trunc","text":"Check_Trunc creates columns use truncation","code":""},{"path":"/reference/Check_Trunc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Applies time duration truncation limits to create columns for Cox model — Check_Trunc","text":"","code":"Check_Trunc(df, ce, verbose = 0)"},{"path":"/reference/Check_Trunc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Applies time duration truncation limits to create columns for Cox model — Check_Trunc","text":"df data.table containing columns interest ce columns check truncation, (t0, t1, event) verbose integer valued 0-4 controlling information printed terminal. level includes lower levels. 0: silent, 1: errors printed, 2: warnings printed, 3: notes printed, 4: debug information printed. Errors situations stop regression, warnings situations assume default values user might intended, notes provide information regression progress, debug prints C++ progress intermediate results. default level 2 True/False converted 3/0.","code":""},{"path":"/reference/Check_Trunc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Applies time duration truncation limits to create columns for Cox model — Check_Trunc","text":"returns updated data time period columns","code":""},{"path":[]},{"path":"/reference/Check_Trunc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Applies time duration truncation limits to create columns for Cox model — Check_Trunc","text":"","code":"library(data.table) df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" ce <- c(\"%trunc%\", \"Ending_Age\") val <- Check_Trunc(df, ce) df <- val$df ce <- val$ce"},{"path":"/reference/Check_Verbose.html","id":null,"dir":"Reference","previous_headings":"","what":"General purpose verbosity check — Check_Verbose","title":"General purpose verbosity check — Check_Verbose","text":"Check_Verbose checks assigns verbosity values","code":""},{"path":"/reference/Check_Verbose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"General purpose verbosity check — Check_Verbose","text":"","code":"Check_Verbose(verbose)"},{"path":"/reference/Check_Verbose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"General purpose verbosity check — Check_Verbose","text":"verbose integer valued 0-4 controlling information printed terminal. level includes lower levels. 0: silent, 1: errors printed, 2: warnings printed, 3: notes printed, 4: debug information printed. Errors situations stop regression, warnings situations assume default values user might intended, notes provide information regression progress, debug prints C++ progress intermediate results. default level 2 True/False converted 3/0.","code":""},{"path":"/reference/Check_Verbose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"General purpose verbosity check — Check_Verbose","text":"returns correct verbose value","code":""},{"path":[]},{"path":"/reference/Convert_Model_Eq.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts a string equation to regression model inputs — Convert_Model_Eq","title":"Converts a string equation to regression model inputs — Convert_Model_Eq","text":"Convert_Model_Eq Converts string expression risk model vectors used different Colossus regression functions","code":""},{"path":"/reference/Convert_Model_Eq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts a string equation to regression model inputs — Convert_Model_Eq","text":"","code":"Convert_Model_Eq(Model_Eq, df)"},{"path":"/reference/Convert_Model_Eq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts a string equation to regression model inputs — Convert_Model_Eq","text":"Model_Eq String representation survival model. Left hand side details model (cox, poisson, cox_strata, poisson_strata), time columns, event, strata used. right hand side details subterm effects. 'Unified Equation Representation' vignette provides details. df data.table containing columns interest","code":""},{"path":"/reference/Convert_Model_Eq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts a string equation to regression model inputs — Convert_Model_Eq","text":"returns list regression inputs","code":""},{"path":[]},{"path":"/reference/Convert_Model_Eq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts a string equation to regression model inputs — Convert_Model_Eq","text":"","code":"library(data.table) a <- c(0, 1, 2, 3, 4, 5, 6) b <- c(1, 2, 3, 4, 5, 6, 7) c <- c(0, 1, 0, 0, 0, 1, 0) d <- c(1, 2, 3, 4, 5, 6, 7) e <- c(2, 3, 4, 5, 6, 7, 8) table <- data.table::data.table(   \"a\" = a, \"b\" = b, \"c\" = c,   \"d\" = d, \"e\" = e ) Model_Eq <- \"cox(a,b, c) ~ loglinear(d, factor(e), 0) + multiplicative()\" e <- Convert_Model_Eq(Model_Eq, table)"},{"path":"/reference/Correct_Formula_Order.html","id":null,"dir":"Reference","previous_headings":"","what":"Corrects the order of terms/formula/etc — Correct_Formula_Order","title":"Corrects the order of terms/formula/etc — Correct_Formula_Order","text":"Correct_Formula_Order checks order formulas given corrects ordering issues, orders alphabetically, term number, etc.","code":""},{"path":"/reference/Correct_Formula_Order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Corrects the order of terms/formula/etc — Correct_Formula_Order","text":"","code":"Correct_Formula_Order(   term_n,   tform,   keep_constant,   a_n,   names,   der_iden = 0,   cons_mat = matrix(c(0)),   cons_vec = c(0),   verbose = FALSE,   model_control = list() )"},{"path":"/reference/Correct_Formula_Order.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Corrects the order of terms/formula/etc — Correct_Formula_Order","text":"term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. names columns elements model, used identify data columns der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 cons_mat Matrix containing coefficients system linear constraints, formatted matrix cons_vec Vector containing constants system linear constraints, formatted vector verbose integer valued 0-4 controlling information printed terminal. level includes lower levels. 0: silent, 1: errors printed, 2: warnings printed, 3: notes printed, 4: debug information printed. Errors situations stop regression, warnings situations assume default values user might intended, notes provide information regression progress, debug prints C++ progress intermediate results. default level 2 True/False converted 3/0. model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details","code":""},{"path":"/reference/Correct_Formula_Order.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Corrects the order of terms/formula/etc — Correct_Formula_Order","text":"returns corrected lists","code":""},{"path":[]},{"path":"/reference/Correct_Formula_Order.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Corrects the order of terms/formula/etc — Correct_Formula_Order","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette term_n <- c(0, 1, 1, 0, 0) tform <- c(\"loglin\", \"quad_slope\", \"lin\", \"lin_int\", \"lin_slope\") keep_constant <- c(0, 0, 0, 1, 0) a_n <- c(1, 2, 3, 4, 5) names <- c(\"a\", \"a\", \"a\", \"a\", \"a\") val <- Correct_Formula_Order(term_n, tform, keep_constant,   a_n, names,   cons_mat = matrix(c(0)),   cons_vec = c(0) ) term_n <- val$term_n tform <- val$tform keep_constant <- val$keep_constant a_n <- val$a_n der_iden <- val$der_iden names <- val$names"},{"path":"/reference/CoxCurveSolver.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the likelihood curve for a cox model directly — CoxCurveSolver","title":"Calculates the likelihood curve for a cox model directly — CoxCurveSolver","text":"CoxCurveSolver solves confidence interval cox model, starting optimum point iteratively optimizing end-points intervals. Intervals updated using bisection method.","code":""},{"path":"/reference/CoxCurveSolver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the likelihood curve for a cox model directly — CoxCurveSolver","text":"","code":"CoxCurveSolver(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   strat_col = \"null\",   cens_weight = \"null\",   model_control = list(),   cons_mat = as.matrix(c(0)),   cons_vec = c(0) )"},{"path":"/reference/CoxCurveSolver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the likelihood curve for a cox model directly — CoxCurveSolver","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") strat_col column stratify needed cens_weight column containing row weights model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details cons_mat Matrix containing coefficients system linear constraints, formatted matrix cons_vec Vector containing constants system linear constraints, formatted vector","code":""},{"path":"/reference/CoxCurveSolver.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the likelihood curve for a cox model directly — CoxCurveSolver","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/Cox_Relative_Risk.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates hazard ratios for a reference vector — Cox_Relative_Risk","title":"Calculates hazard ratios for a reference vector — Cox_Relative_Risk","text":"RunCoxRegression uses user provided data,  vectors specifying model, options calculate relative risk every row provided data","code":""},{"path":"/reference/Cox_Relative_Risk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates hazard ratios for a reference vector — Cox_Relative_Risk","text":"","code":"Cox_Relative_Risk(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   control = list(),   model_control = list() )"},{"path":"/reference/Cox_Relative_Risk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates hazard ratios for a reference vector — Cox_Relative_Risk","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details","code":""},{"path":"/reference/Cox_Relative_Risk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates hazard ratios for a reference vector — Cox_Relative_Risk","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/Cox_Relative_Risk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates hazard ratios for a reference vector — Cox_Relative_Risk","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") term_n <- c(0, 1, 1, 2) fir <- 0 tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" a_n <- c(1.1, 0.1, 0.2, 0.5) # used to test at a specific point keep_constant <- c(0, 0, 0, 0) control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5, \"halfmax\" = 5,   \"epsilon\" = 1e-3,   \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE, \"ties\" = \"breslow\",   \"double_step\" = 1 ) e <- Cox_Relative_Risk(   df, time1, time2, event, names, term_n, tform,   keep_constant, a_n, modelform, fir, control )"},{"path":"/reference/Date_Shift.html","id":null,"dir":"Reference","previous_headings":"","what":"Automates creating a date difference column — Date_Shift","title":"Automates creating a date difference column — Date_Shift","text":"Date_Shift generates new dataframe column containing time difference given unit","code":""},{"path":"/reference/Date_Shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automates creating a date difference column — Date_Shift","text":"","code":"Date_Shift(df, dcol0, dcol1, col_name, units = \"days\")"},{"path":"/reference/Date_Shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automates creating a date difference column — Date_Shift","text":"df data.table containing columns interest dcol0 list starting month, day, year dcol1 list ending month, day, year col_name vector new column names units time unit use","code":""},{"path":"/reference/Date_Shift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automates creating a date difference column — Date_Shift","text":"returns updated dataframe","code":""},{"path":[]},{"path":"/reference/Date_Shift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automates creating a date difference column — Date_Shift","text":"","code":"library(data.table) m0 <- c(1, 1, 2, 2) m1 <- c(2, 2, 3, 3) d0 <- c(1, 2, 3, 4) d1 <- c(6, 7, 8, 9) y0 <- c(1990, 1991, 1997, 1998) y1 <- c(2001, 2003, 2005, 2006) df <- data.table::data.table(\"m0\" = m0, \"m1\" = m1, \"d0\" = d0, \"d1\" = d1, \"y0\" = y0, \"y1\" = y1) df <- Date_Shift(df, c(\"m0\", \"d0\", \"y0\"), c(\"m1\", \"d1\", \"y1\"), \"date_since\")"},{"path":"/reference/Def_Control.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatically assigns missing control values — Def_Control","title":"Automatically assigns missing control values — Def_Control","text":"Def_Control checks assigns default values","code":""},{"path":"/reference/Def_Control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatically assigns missing control values — Def_Control","text":"","code":"Def_Control(control)"},{"path":"/reference/Def_Control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatically assigns missing control values — Def_Control","text":"control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\")","code":""},{"path":"/reference/Def_Control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatically assigns missing control values — Def_Control","text":"returns filled list","code":""},{"path":[]},{"path":"/reference/Def_Control.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatically assigns missing control values — Def_Control","text":"","code":"library(data.table) control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5,   \"ties\" = \"breslow\", \"double_step\" = 1 ) control <- Def_Control(control)"},{"path":"/reference/Def_Control_Guess.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatically assigns missing guessing control values — Def_Control_Guess","title":"Automatically assigns missing guessing control values — Def_Control_Guess","text":"Def_Control_Guess checks assigns default values","code":""},{"path":"/reference/Def_Control_Guess.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatically assigns missing guessing control values — Def_Control_Guess","text":"","code":"Def_Control_Guess(guesses_control, a_n)"},{"path":"/reference/Def_Control_Guess.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatically assigns missing guessing control values — Def_Control_Guess","text":"guesses_control list parameters control guessing works, see Def_Control_Guess() options vignette(\"Control_Options\") a_n list initial parameter values, used determine number parameters. May either list vectors single vector.","code":""},{"path":"/reference/Def_Control_Guess.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatically assigns missing guessing control values — Def_Control_Guess","text":"returns filled list","code":""},{"path":[]},{"path":"/reference/Def_Control_Guess.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatically assigns missing guessing control values — Def_Control_Guess","text":"","code":"library(data.table) guesses_control <- list(   \"maxiter\" = 10, \"guesses\" = 10,   \"loglin_min\" = -1, \"loglin_max\" = 1, \"loglin_method\" = \"uniform\" ) a_n <- c(0.1, 2, 1.3) guesses_control <- Def_Control_Guess(guesses_control, a_n)"},{"path":"/reference/Def_model_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatically assigns missing model control values — Def_model_control","title":"Automatically assigns missing model control values — Def_model_control","text":"Def_model_control checks assigns default values","code":""},{"path":"/reference/Def_model_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatically assigns missing model control values — Def_model_control","text":"","code":"Def_model_control(control)"},{"path":"/reference/Def_model_control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatically assigns missing model control values — Def_model_control","text":"control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\")","code":""},{"path":"/reference/Def_model_control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatically assigns missing model control values — Def_model_control","text":"returns filled list","code":""},{"path":[]},{"path":"/reference/Def_model_control.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatically assigns missing model control values — Def_model_control","text":"","code":"library(data.table) control <- list(\"single\" = TRUE) control <- Def_model_control(control)"},{"path":"/reference/Def_modelform_fix.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatically assigns geometric-mixture values and checks that a valid modelform is used — Def_modelform_fix","title":"Automatically assigns geometric-mixture values and checks that a valid modelform is used — Def_modelform_fix","text":"Def_modelform_fix checks assigns default values modelform options","code":""},{"path":"/reference/Def_modelform_fix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatically assigns geometric-mixture values and checks that a valid modelform is used — Def_modelform_fix","text":"","code":"Def_modelform_fix(control, model_control, modelform, term_n)"},{"path":"/reference/Def_modelform_fix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatically assigns geometric-mixture values and checks that a valid modelform is used — Def_modelform_fix","text":"control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E term_n term numbers element model","code":""},{"path":"/reference/Def_modelform_fix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatically assigns geometric-mixture values and checks that a valid modelform is used — Def_modelform_fix","text":"returns filled list","code":""},{"path":[]},{"path":"/reference/Def_modelform_fix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatically assigns geometric-mixture values and checks that a valid modelform is used — Def_modelform_fix","text":"","code":"library(data.table) control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5,   \"ties\" = \"breslow\", \"double_step\" = 1 ) control <- Def_Control(control) model_control <- list(\"single\" = TRUE) model_control <- Def_model_control(model_control) term_n <- c(0, 1, 1) modelform <- \"a\" val <- Def_modelform_fix(control, model_control, modelform, term_n) model_control <- val$model_control modelform <- val$modelform"},{"path":"/reference/Event_Count_Gen.html","id":null,"dir":"Reference","previous_headings":"","what":"uses a table, list of categories, and list of event summaries to generate person-count tables — Event_Count_Gen","title":"uses a table, list of categories, and list of event summaries to generate person-count tables — Event_Count_Gen","text":"Event_Count_Gen generates event-count tables","code":""},{"path":"/reference/Event_Count_Gen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"uses a table, list of categories, and list of event summaries to generate person-count tables — Event_Count_Gen","text":"","code":"Event_Count_Gen(table, categ, events, verbose = FALSE)"},{"path":"/reference/Event_Count_Gen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"uses a table, list of categories, and list of event summaries to generate person-count tables — Event_Count_Gen","text":"table dataframe every category/event column needed categ list category columns methods, methods can either strings lists boundaries events list columns summarize, supports counts means renaming summary column verbose integer valued 0-4 controlling information printed terminal. level includes lower levels. 0: silent, 1: errors printed, 2: warnings printed, 3: notes printed, 4: debug information printed. Errors situations stop regression, warnings situations assume default values user might intended, notes provide information regression progress, debug prints C++ progress intermediate results. default level 2 True/False converted 3/0.","code":""},{"path":"/reference/Event_Count_Gen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"uses a table, list of categories, and list of event summaries to generate person-count tables — Event_Count_Gen","text":"returns grouped table list category boundaries used","code":""},{"path":[]},{"path":"/reference/Event_Count_Gen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"uses a table, list of categories, and list of event summaries to generate person-count tables — Event_Count_Gen","text":"","code":"library(data.table) a <- c(0, 1, 2, 3, 4, 5, 6) b <- c(1, 2, 3, 4, 5, 6, 7) c <- c(0, 1, 0, 0, 0, 1, 0) table <- data.table::data.table(   \"a\" = a,   \"b\" = b,   \"c\" = c ) categ <- list(   \"a\" = \"0/3/5]7\",   \"b\" = list(     lower = c(-1, 3, 6),     upper = c(3, 6, 10),     name = c(\"low\", \"medium\", \"high\")   ) ) event <- list(   \"c\" = \"count AS cases\",   \"a\" = \"mean\", \"b\" = \"mean\" ) e <- Event_Count_Gen(table, categ, event, T)"},{"path":"/reference/Event_Time_Gen.html","id":null,"dir":"Reference","previous_headings":"","what":"uses a table, list of categories, list of summaries, list of events, and person-year information to generate person-time tables — Event_Time_Gen","title":"uses a table, list of categories, list of summaries, list of events, and person-year information to generate person-time tables — Event_Time_Gen","text":"Event_Time_Gen generates event-time tables","code":""},{"path":"/reference/Event_Time_Gen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"uses a table, list of categories, list of summaries, list of events, and person-year information to generate person-time tables — Event_Time_Gen","text":"","code":"Event_Time_Gen(table, pyr, categ, summaries, events, verbose = FALSE)"},{"path":"/reference/Event_Time_Gen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"uses a table, list of categories, list of summaries, list of events, and person-year information to generate person-time tables — Event_Time_Gen","text":"table dataframe every category/event column needed pyr list entry exit lists, containing day/month/year columns table categ list category columns methods, methods can either strings lists boundaries, includes time category entry/exit required pyr list summaries list columns summarize, supports counts, means, weighted means person-year renaming summary column events list events interests, checks events within time interval verbose integer valued 0-4 controlling information printed terminal. level includes lower levels. 0: silent, 1: errors printed, 2: warnings printed, 3: notes printed, 4: debug information printed. Errors situations stop regression, warnings situations assume default values user might intended, notes provide information regression progress, debug prints C++ progress intermediate results. default level 2 True/False converted 3/0.","code":""},{"path":"/reference/Event_Time_Gen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"uses a table, list of categories, list of summaries, list of events, and person-year information to generate person-time tables — Event_Time_Gen","text":"returns grouped table list category boundaries used","code":""},{"path":[]},{"path":"/reference/Event_Time_Gen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"uses a table, list of categories, list of summaries, list of events, and person-year information to generate person-time tables — Event_Time_Gen","text":"","code":"library(data.table) a <- c(0, 1, 2, 3, 4, 5, 6) b <- c(1, 2, 3, 4, 5, 6, 7) c <- c(0, 1, 0, 0, 0, 1, 0) d <- c(1, 2, 3, 4, 5, 6, 7) e <- c(2, 3, 4, 5, 6, 7, 8) f <- c(   1900, 1900, 1900, 1900,   1900, 1900, 1900 ) g <- c(1, 2, 3, 4, 5, 6, 7) h <- c(2, 3, 4, 5, 6, 7, 8) i <- c(   1901, 1902, 1903, 1904,   1905, 1906, 1907 ) table <- data.table::data.table(   \"a\" = a, \"b\" = b, \"c\" = c,   \"d\" = d, \"e\" = e, \"f\" = f,   \"g\" = g, \"h\" = h, \"i\" = i ) categ <- list(   \"a\" = \"-1/3/5]7\",   \"b\" = list(     lower = c(-1, 3, 6), upper = c(3, 6, 10),     name = c(\"low\", \"medium\", \"high\")   ),   \"time AS time\" = list(     \"day\" = c(1, 1, 1, 1, 1),     \"month\" = c(1, 1, 1, 1, 1),     \"year\" = c(1899, 1903, 1910)   ) ) summary <- list(   \"c\" = \"count AS cases\",   \"a\" = \"mean\",   \"b\" = \"weighted_mean\" ) events <- list(\"c\") pyr <- list(   entry = list(year = \"f\", month = \"e\", day = \"d\"),   exit = list(year = \"i\", month = \"h\", day = \"g\"),   unit = \"years\" ) e <- Event_Time_Gen(table, pyr, categ, summary, events, T)"},{"path":"/reference/Gather_Guesses_CPP.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs checks to gather a list of guesses and iterations — Gather_Guesses_CPP","title":"Performs checks to gather a list of guesses and iterations — Gather_Guesses_CPP","text":"Gather_Guesses_CPP called within R, uses list options model definition generate list parameters iterations produce errors","code":""},{"path":"/reference/Gather_Guesses_CPP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs checks to gather a list of guesses and iterations — Gather_Guesses_CPP","text":"","code":"Gather_Guesses_CPP(   df,   dfc,   names,   term_n,   tform,   keep_constant,   a_n,   x_all,   a_n_default,   modelform,   fir,   control,   guesses_control,   model_control = list() )"},{"path":"/reference/Gather_Guesses_CPP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs checks to gather a list of guesses and iterations — Gather_Guesses_CPP","text":"df data.table containing columns interest dfc vector matching subterm number matrix column names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. x_all covariate matrix a_n_default center parameter distribution guessing scope modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") guesses_control list parameters control guessing works, see Def_Control_Guess() options vignette(\"Control_Options\") model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details","code":""},{"path":"/reference/Gather_Guesses_CPP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs checks to gather a list of guesses and iterations — Gather_Guesses_CPP","text":"returns list final results","code":""},{"path":"/reference/Gather_Guesses_CPP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs checks to gather a list of guesses and iterations — Gather_Guesses_CPP","text":"","code":"library(data.table) a <- c(0, 1, 2, 3, 4, 5, 6) b <- c(1, 2, 3, 4, 5, 6, 7) c <- c(0, 1, 0, 0, 0, 1, 0) d <- c(3, 4, 5, 6, 7, 8, 9) df <- data.table::data.table(\"a\" = a, \"b\" = b, \"c\" = c, \"d\" = d) time1 <- \"a\" time2 <- \"b\" event <- \"c\" names <- c(\"d\") term_n <- c(0) tform <- c(\"loglin\") keep_constant <- c(0) a_n <- c(-0.1) a_n_default <- a_n modelform <- \"M\" fir <- 0 der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = -1,   \"halfmax\" = 5, \"epsilon\" = 1e-9,   \"deriv_epsilon\" = 1e-9, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE, \"ties\" = \"breslow\",   \"double_step\" = 1 ) guesses_control <- list() model_control <- list() all_names <- unique(names(df)) dfc <- match(names, all_names) term_tot <- max(term_n) + 1 x_all <- as.matrix(df[, all_names, with = FALSE]) control <- Def_Control(control) guesses_control <- Def_Control_Guess(guesses_control, a_n) model_control <- Def_model_control(model_control) options(warn = -1) Gather_Guesses_CPP(   df, dfc, names, term_n, tform, keep_constant,   a_n, x_all, a_n_default,   modelform, fir, control, guesses_control ) #> $a_ns #>  [1] -0.1000000 -0.9384997  0.5686661  0.1015218 -0.7855831 -1.0852011 #>  [7] -0.1672130 -0.1044452 -0.5204655  0.3657640 #>  #> $maxiters #>  [1] 5 5 5 5 5 5 5 5 5 5 #>"},{"path":"/reference/GetCensWeight.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates and returns data for time by hazard and survival to estimate censoring rate — GetCensWeight","title":"Calculates and returns data for time by hazard and survival to estimate censoring rate — GetCensWeight","text":"GetCensWeight uses user provided data, time/event columns, vectors specifying model, options generate estimate censoring rate, plots, returns data","code":""},{"path":"/reference/GetCensWeight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates and returns data for time by hazard and survival to estimate censoring rate — GetCensWeight","text":"","code":"GetCensWeight(   df,   time1,   time2,   event0,   names,   term_n,   tform,   keep_constant,   a_n,   modelform,   fir,   control,   plot_options,   model_control = list(),   strat_col = \"e\" )"},{"path":"/reference/GetCensWeight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates and returns data for time by hazard and survival to estimate censoring rate — GetCensWeight","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") plot_options list parameters controlling plot options, see RunCoxPlots() different options model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details strat_col column stratify needed","code":""},{"path":"/reference/GetCensWeight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates and returns data for time by hazard and survival to estimate censoring rate — GetCensWeight","text":"saves plots current directory returns data.table time corresponding hazard, cumulative hazard, survival","code":""},{"path":"/reference/GetCensWeight.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates and returns data for time by hazard and survival to estimate censoring rate — GetCensWeight","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 a_n <- c(0.1, 0.1, 0.1, 0.1) keep_constant <- c(0, 0, 0, 0) der_iden <- 0 df$censor <- (df$Cancer_Status == 0) event <- \"censor\" control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 20, \"halfmax\" = 5,   \"epsilon\" = 1e-6, \"deriv_epsilon\" = 1e-6,   \"abs_max\" = 1.0, \"change_all\" = TRUE, \"dose_abs_max\" = 100.0, \"verbose\" = FALSE,   \"ties\" = \"breslow\", \"double_step\" = 1 ) plot_options <- list(   \"name\" = paste(tempfile(), \"run_06\", sep = \"\"), \"verbose\" = FALSE,   \"studyID\" = \"studyID\", \"age_unit\" = \"years\" ) dft <- GetCensWeight(   df, time1, time2, event, names, term_n, tform,   keep_constant, a_n, modelform, fir, control, plot_options ) t_ref <- dft$t surv_ref <- dft$surv t_c <- df$t1 cens_weight <- approx(t_ref, surv_ref, t_c, rule = 2)$y"},{"path":"/reference/Interpret_Output.html","id":null,"dir":"Reference","previous_headings":"","what":"Prints a regression output clearly — Interpret_Output","title":"Prints a regression output clearly — Interpret_Output","text":"Interpret_Output uses list output regression, prints table results summarizes score convergence.","code":""},{"path":"/reference/Interpret_Output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prints a regression output clearly — Interpret_Output","text":"","code":"Interpret_Output(out_list, digits = 2)"},{"path":"/reference/Interpret_Output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prints a regression output clearly — Interpret_Output","text":"out_list list output regression, used build results table pull convergence values digits digits used printing results","code":""},{"path":"/reference/Interpret_Output.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prints a regression output clearly — Interpret_Output","text":"return nothing, prints results console","code":""},{"path":[]},{"path":"/reference/Interpret_Output.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prints a regression output clearly — Interpret_Output","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1),   \"e\" = c(0, 0, 1, 0, 0, 0, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") a_n <- list(c(1.1, -0.1, 0.2, 0.5), c(1.6, -0.12, 0.3, 0.4)) # used to test at a specific point term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiters\" = c(5, 5, 5),   \"halfmax\" = 5, \"epsilon\" = 1e-3, \"deriv_epsilon\" = 1e-3,   \"abs_max\" = 1.0, \"change_all\" = TRUE, \"dose_abs_max\" = 100.0,   \"verbose\" = FALSE,   \"ties\" = \"breslow\", \"double_step\" = 1, \"guesses\" = 2 ) e <- RunCoxRegression_Omnibus(df, time1, time2, event,   names, term_n, tform, keep_constant,   a_n, modelform, fir, der_iden, control,   model_control = list(     \"single\" = FALSE,     \"basic\" = FALSE, \"cr\" = FALSE, \"null\" = FALSE   ) ) Interpret_Output(e) #> |-------------------------------------------------------------------| #> Final Results #>    Covariate Subterm Term Number Central Estimate Standard Deviation #>       <char>  <char>       <int>            <num>              <num> #> 1:         a  loglin           0        7.6000000           21.75009 #> 2:         b     lin           1        0.1541029          333.48693 #> 3:         c     lin           1        3.3758662         3963.75979 #> 4:         d    plin           2        6.4000000           57.28494 #>  #> Cox Model Used #> -2*Log-Likelihood: 1.7,  AIC: 9.7 #> Iterations run: 5 #> maximum step size: 1.00e+00, maximum first derivative: 2.12e-02 #> Analysis did not converge, check convergence criteria or run further #> Run finished in 0.05 seconds #> |-------------------------------------------------------------------|"},{"path":"/reference/Joint_Multiple_Events.html","id":null,"dir":"Reference","previous_headings":"","what":"Automates creating data for a joint competing risks analysis — Joint_Multiple_Events","title":"Automates creating data for a joint competing risks analysis — Joint_Multiple_Events","text":"Joint_Multiple_Events generates input regression multiple non-independent events models","code":""},{"path":"/reference/Joint_Multiple_Events.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automates creating data for a joint competing risks analysis — Joint_Multiple_Events","text":"","code":"Joint_Multiple_Events(   df,   events,   name_list,   term_n_list = list(),   tform_list = list(),   keep_constant_list = list(),   a_n_list = list() )"},{"path":"/reference/Joint_Multiple_Events.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automates creating data for a joint competing risks analysis — Joint_Multiple_Events","text":"df data.table containing columns interest events vector event column names name_list list vectors columns event specific shared model elements, required term_n_list list vectors term numbers event specific shared model elements, defaults term 0 tform_list list vectors subterm types event specific shared model elements, defaults loglinear keep_constant_list list vectors constant elements event specific shared model elements, defaults free (0) a_n_list list vectors parameter values event specific shared model elements, defaults term 0","code":""},{"path":"/reference/Joint_Multiple_Events.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automates creating data for a joint competing risks analysis — Joint_Multiple_Events","text":"returns updated dataframe model inputs","code":""},{"path":[]},{"path":"/reference/Joint_Multiple_Events.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automates creating data for a joint competing risks analysis — Joint_Multiple_Events","text":"","code":"library(data.table) a <- c(0, 0, 0, 1, 1, 1) b <- c(1, 1, 1, 2, 2, 2) c <- c(0, 1, 2, 2, 1, 0) d <- c(1, 1, 0, 0, 1, 1) e <- c(0, 1, 1, 1, 0, 0) df <- data.table(\"t0\" = a, \"t1\" = b, \"e0\" = c, \"e1\" = d, \"fac\" = e) time1 <- \"t0\" time2 <- \"t1\" df$pyr <- df$t1 - df$t0 pyr <- \"pyr\" events <- c(\"e0\", \"e1\") names_e0 <- c(\"fac\") names_e1 <- c(\"fac\") names_shared <- c(\"t0\", \"t0\") term_n_e0 <- c(0) term_n_e1 <- c(0) term_n_shared <- c(0, 0) tform_e0 <- c(\"loglin\") tform_e1 <- c(\"loglin\") tform_shared <- c(\"quad_slope\", \"loglin_top\") keep_constant_e0 <- c(0) keep_constant_e1 <- c(0) keep_constant_shared <- c(0, 0) a_n_e0 <- c(-0.1) a_n_e1 <- c(0.1) a_n_shared <- c(0.001, -0.02) name_list <- list(\"shared\" = names_shared, \"e0\" = names_e0, \"e1\" = names_e1) term_n_list <- list(\"shared\" = term_n_shared, \"e0\" = term_n_e0, \"e1\" = term_n_e1) tform_list <- list(\"shared\" = tform_shared, \"e0\" = tform_e0, \"e1\" = tform_e1) keep_constant_list <- list(   \"shared\" = keep_constant_shared,   \"e0\" = keep_constant_e0, \"e1\" = keep_constant_e1 ) a_n_list <- list(\"shared\" = a_n_shared, \"e0\" = a_n_e0, \"e1\" = a_n_e1) val <- Joint_Multiple_Events(   df, events, name_list, term_n_list,   tform_list, keep_constant_list, a_n_list )"},{"path":"/reference/Likelihood_Ratio_Test.html","id":null,"dir":"Reference","previous_headings":"","what":"Defines the likelihood ratio test — Likelihood_Ratio_Test","title":"Defines the likelihood ratio test — Likelihood_Ratio_Test","text":"Likelihood_Ratio_Test uses two models calculates ratio","code":""},{"path":"/reference/Likelihood_Ratio_Test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defines the likelihood ratio test — Likelihood_Ratio_Test","text":"","code":"Likelihood_Ratio_Test(alternative_model, null_model)"},{"path":"/reference/Likelihood_Ratio_Test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Defines the likelihood ratio test — Likelihood_Ratio_Test","text":"alternative_model new model interest list form, output poisson regression null_model model compare , list form","code":""},{"path":"/reference/Likelihood_Ratio_Test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Defines the likelihood ratio test — Likelihood_Ratio_Test","text":"returns score statistic","code":""},{"path":"/reference/Likelihood_Ratio_Test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Defines the likelihood ratio test — Likelihood_Ratio_Test","text":"","code":"library(data.table) # In an actual example, one would run two seperate RunCoxRegression regressions, #    assigning the results to e0 and e1 e0 <- list(\"name\" = \"First Model\", \"LogLik\" = -120) e1 <- list(\"name\" = \"New Model\", \"LogLik\" = -100) score <- Likelihood_Ratio_Test(e1, e0)"},{"path":"/reference/Linked_Dose_Formula.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates Full Parameter list for Special Dose Formula — Linked_Dose_Formula","title":"Calculates Full Parameter list for Special Dose Formula — Linked_Dose_Formula","text":"Linked_Dose_Formula Calculates parameters linear-quadratic linear-exponential linked formulas","code":""},{"path":"/reference/Linked_Dose_Formula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates Full Parameter list for Special Dose Formula — Linked_Dose_Formula","text":"","code":"Linked_Dose_Formula(tforms, paras, verbose = 0)"},{"path":"/reference/Linked_Dose_Formula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates Full Parameter list for Special Dose Formula — Linked_Dose_Formula","text":"tforms list formula types paras list formula parameters verbose integer valued 0-4 controlling information printed terminal. level includes lower levels. 0: silent, 1: errors printed, 2: warnings printed, 3: notes printed, 4: debug information printed. Errors situations stop regression, warnings situations assume default values user might intended, notes provide information regression progress, debug prints C++ progress intermediate results. default level 2 True/False converted 3/0.","code":""},{"path":"/reference/Linked_Dose_Formula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates Full Parameter list for Special Dose Formula — Linked_Dose_Formula","text":"returns list full parameters","code":""},{"path":"/reference/Linked_Dose_Formula.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates Full Parameter list for Special Dose Formula — Linked_Dose_Formula","text":"","code":"library(data.table) tforms <- list(\"cov_0\" = \"quad\", \"cov_1\" = \"exp\") paras <- list(\"cov_0\" = c(1, 3.45), \"cov_1\" = c(1.2, 4.5, 0.1)) full_paras <- Linked_Dose_Formula(tforms, paras)"},{"path":"/reference/Linked_Lin_Exp_Para.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates The Additional Parameter For a linear-exponential formula with known maximum — Linked_Lin_Exp_Para","title":"Calculates The Additional Parameter For a linear-exponential formula with known maximum — Linked_Lin_Exp_Para","text":"Linked_Lin_Exp_Para Calculates additional parameter desired maximum","code":""},{"path":"/reference/Linked_Lin_Exp_Para.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates The Additional Parameter For a linear-exponential formula with known maximum — Linked_Lin_Exp_Para","text":"","code":"Linked_Lin_Exp_Para(y, a0, a1_goal, verbose = 0)"},{"path":"/reference/Linked_Lin_Exp_Para.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates The Additional Parameter For a linear-exponential formula with known maximum — Linked_Lin_Exp_Para","text":"y point formula switch a0 linear slope a1_goal exponential maximum desired verbose integer valued 0-4 controlling information printed terminal. level includes lower levels. 0: silent, 1: errors printed, 2: warnings printed, 3: notes printed, 4: debug information printed. Errors situations stop regression, warnings situations assume default values user might intended, notes provide information regression progress, debug prints C++ progress intermediate results. default level 2 True/False converted 3/0.","code":""},{"path":"/reference/Linked_Lin_Exp_Para.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates The Additional Parameter For a linear-exponential formula with known maximum — Linked_Lin_Exp_Para","text":"returns parameter used Colossus","code":""},{"path":"/reference/Linked_Lin_Exp_Para.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates The Additional Parameter For a linear-exponential formula with known maximum — Linked_Lin_Exp_Para","text":"","code":"library(data.table) y <- 7.6 a0 <- 1.2 a1_goal <- 15 full_paras <- Linked_Lin_Exp_Para(y, a0, a1_goal)"},{"path":"/reference/Model_Results_Log.html","id":null,"dir":"Reference","previous_headings":"","what":"Saves information about a run to a log file — Model_Results_Log","title":"Saves information about a run to a log file — Model_Results_Log","text":"Model_Results_Log saves information data, results, model, computer, software, date external file. Intended make reproduction results easier","code":""},{"path":"/reference/Model_Results_Log.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Saves information about a run to a log file — Model_Results_Log","text":"","code":"Model_Results_Log(   log_file = \"out.log\",   df = data.table(),   out_list = list(),   noprint = TRUE )"},{"path":"/reference/Model_Results_Log.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Saves information about a run to a log file — Model_Results_Log","text":"log_file file save log df data.table containing columns interest out_list list output regression, used build results table pull convergence values noprint boolean, true file saved log file, false output printed console INSTEAD saved.","code":""},{"path":"/reference/Model_Results_Log.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Saves information about a run to a log file — Model_Results_Log","text":"null, prints screen saves file","code":""},{"path":[]},{"path":"/reference/OMP_Check.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks the OMP flag — OMP_Check","title":"Checks the OMP flag — OMP_Check","text":"OMP_Check Called directly R, checks omp flag returns omp enabled","code":""},{"path":"/reference/OMP_Check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks the OMP flag — OMP_Check","text":"","code":"OMP_Check()"},{"path":"/reference/OMP_Check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks the OMP flag — OMP_Check","text":"boolean: True OMP allowed","code":""},{"path":"/reference/PoissonCurveSolver.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the likelihood curve for a poisson model directly — PoissonCurveSolver","title":"Calculates the likelihood curve for a poisson model directly — PoissonCurveSolver","text":"PoissonCurveSolver solves confidence interval poisson model, starting optimum point iteratively optimizing point using bisection method","code":""},{"path":"/reference/PoissonCurveSolver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the likelihood curve for a poisson model directly — PoissonCurveSolver","text":"","code":"PoissonCurveSolver(   df,   pyr0 = \"pyr\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   strat_col = \"null\",   model_control = list(),   cons_mat = as.matrix(c(0)),   cons_vec = c(0) )"},{"path":"/reference/PoissonCurveSolver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the likelihood curve for a poisson model directly — PoissonCurveSolver","text":"df data.table containing columns interest pyr0 column used person-years per row event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") strat_col column stratify needed model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details cons_mat Matrix containing coefficients system linear constraints, formatted matrix cons_vec Vector containing constants system linear constraints, formatted vector","code":""},{"path":"/reference/PoissonCurveSolver.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the likelihood curve for a poisson model directly — PoissonCurveSolver","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/Rcomp_version.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks how R was compiled — Rcomp_version","title":"Checks how R was compiled — Rcomp_version","text":"Rcomp_version Checks R compiled, part configuration script","code":""},{"path":"/reference/Rcomp_version.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks how R was compiled — Rcomp_version","text":"","code":"Rcomp_version()"},{"path":"/reference/Rcomp_version.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks how R was compiled — Rcomp_version","text":"returns string representation gcc, clang, R CMD config CC output","code":""},{"path":"/reference/Rcpp_version.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks default R c++ compiler — Rcpp_version","title":"Checks default R c++ compiler — Rcpp_version","text":"Rcpp_version checks ~/.R/Makevars script default compilers set, part configuration script","code":""},{"path":"/reference/Rcpp_version.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks default R c++ compiler — Rcpp_version","text":"","code":"Rcpp_version()"},{"path":"/reference/Rcpp_version.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks default R c++ compiler — Rcpp_version","text":"returns string representation gcc, clang, head ~/.R/Makevars","code":""},{"path":"/reference/Replace_Missing.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatically assigns missing values in listed columns — Replace_Missing","title":"Automatically assigns missing values in listed columns — Replace_Missing","text":"Replace_Missing checks column fills NA values","code":""},{"path":"/reference/Replace_Missing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatically assigns missing values in listed columns — Replace_Missing","text":"","code":"Replace_Missing(df, name_list, msv, verbose = FALSE)"},{"path":"/reference/Replace_Missing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatically assigns missing values in listed columns — Replace_Missing","text":"df data.table containing columns interest name_list vector string column names check msv value replace na , used every column used verbose integer valued 0-4 controlling information printed terminal. level includes lower levels. 0: silent, 1: errors printed, 2: warnings printed, 3: notes printed, 4: debug information printed. Errors situations stop regression, warnings situations assume default values user might intended, notes provide information regression progress, debug prints C++ progress intermediate results. default level 2 True/False converted 3/0.","code":""},{"path":"/reference/Replace_Missing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatically assigns missing values in listed columns — Replace_Missing","text":"returns filled datatable","code":""},{"path":[]},{"path":"/reference/Replace_Missing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatically assigns missing values in listed columns — Replace_Missing","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, NA, 47, 36, NA, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0) ) df <- Replace_Missing(df, c(\"Starting_Age\", \"Ending_Age\"), 70)"},{"path":"/reference/RunCaseControlRegression_Omnibus.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs Matched Case-Control Conditional Logistic Regression — RunCaseControlRegression_Omnibus","title":"Performs Matched Case-Control Conditional Logistic Regression — RunCaseControlRegression_Omnibus","text":"RunCaseControlRegression_Omnibus uses user provided data, time/event columns, vectors specifying model, options control convergence starting positions. additional options starting several initial guesses, using stratification /matching time risk, calculation without derivatives","code":""},{"path":"/reference/RunCaseControlRegression_Omnibus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs Matched Case-Control Conditional Logistic Regression — RunCaseControlRegression_Omnibus","text":"","code":"RunCaseControlRegression_Omnibus(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   strat_col = \"null\",   cens_weight = \"null\",   model_control = list(),   cons_mat = as.matrix(c(0)),   cons_vec = c(0) )"},{"path":"/reference/RunCaseControlRegression_Omnibus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs Matched Case-Control Conditional Logistic Regression — RunCaseControlRegression_Omnibus","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") strat_col column stratify needed cens_weight column containing row weights model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details cons_mat Matrix containing coefficients system linear constraints, formatted matrix cons_vec Vector containing constants system linear constraints, formatted vector","code":""},{"path":"/reference/RunCaseControlRegression_Omnibus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs Matched Case-Control Conditional Logistic Regression — RunCaseControlRegression_Omnibus","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunCaseControlRegression_Omnibus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs Matched Case-Control Conditional Logistic Regression — RunCaseControlRegression_Omnibus","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1),   \"e\" = c(0, 0, 1, 0, 0, 0, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") a_n <- list(c(1.1, -0.1, 0.2, 0.5), c(1.6, -0.12, 0.3, 0.4)) # used to test at a specific point term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiters\" = c(5, 5, 5),   \"halfmax\" = 5, \"epsilon\" = 1e-3, \"deriv_epsilon\" = 1e-3,   \"abs_max\" = 1.0, \"change_all\" = TRUE, \"dose_abs_max\" = 100.0,   \"verbose\" = FALSE,   \"ties\" = \"breslow\", \"double_step\" = 1, \"guesses\" = 2 ) e <- RunCaseControlRegression_Omnibus(df, time1, time2, event,   names, term_n, tform, keep_constant,   a_n, modelform, fir, der_iden, control,   model_control = list(     \"stata\" = FALSE,     \"time_risk\" = FALSE   ) )"},{"path":"/reference/RunCoxNull.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs basic Cox Proportional Hazards regression with the null model — RunCoxNull","title":"Performs basic Cox Proportional Hazards regression with the null model — RunCoxNull","text":"RunCoxRegression uses user provided data time/event columns calculate log-likelihood constant hazard ratio","code":""},{"path":"/reference/RunCoxNull.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs basic Cox Proportional Hazards regression with the null model — RunCoxNull","text":"","code":"RunCoxNull(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   control = list() )"},{"path":"/reference/RunCoxNull.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs basic Cox Proportional Hazards regression with the null model — RunCoxNull","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\")","code":""},{"path":"/reference/RunCoxNull.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs basic Cox Proportional Hazards regression with the null model — RunCoxNull","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunCoxNull.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs basic Cox Proportional Hazards regression with the null model — RunCoxNull","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" control <- list(   \"ncores\" = 2, \"verbose\" = FALSE, \"ties\" = \"breslow\",   \"double_step\" = 1 ) e <- RunCoxNull(df, time1, time2, event, control)"},{"path":"/reference/RunCoxPlots.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs Cox Proportional Hazard model plots — RunCoxPlots","title":"Performs Cox Proportional Hazard model plots — RunCoxPlots","text":"RunCoxPlots uses user provided data, time/event columns, vectors specifying model, options choose save plots","code":""},{"path":"/reference/RunCoxPlots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs Cox Proportional Hazard model plots — RunCoxPlots","text":"","code":"RunCoxPlots(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   control = list(),   plot_options = list(),   model_control = list() )"},{"path":"/reference/RunCoxPlots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs Cox Proportional Hazard model plots — RunCoxPlots","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") plot_options list parameters controlling plot options, see RunCoxPlots() different options model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details","code":""},{"path":"/reference/RunCoxPlots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs Cox Proportional Hazard model plots — RunCoxPlots","text":"saves plots current directory returns data used plots","code":""},{"path":[]},{"path":"/reference/RunCoxPlots.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs Cox Proportional Hazard model plots — RunCoxPlots","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 a_n <- c(-0.1, 0.5, 1.1, -0.3) keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = -1, \"halfmax\" = 5,   \"epsilon\" = 1e-3, \"deriv_epsilon\" = 1e-3,   \"abs_max\" = 1.0, \"change_all\" = TRUE, \"dose_abs_max\" = 100.0,   \"verbose\" = FALSE, \"ties\" = \"breslow\", \"double_step\" = 1 ) # setting maxiter below 0 forces the function to calculate the score # and return plot_options <- list(   \"type\" = c(\"surv\", paste(tempfile(),     \"run\",     sep = \"\"   )), \"studyid\" = \"UserID\",   \"verbose\" = FALSE ) RunCoxPlots(   df, time1, time2, event, names, term_n, tform, keep_constant,   a_n, modelform, fir, control, plot_options ) #> list()"},{"path":"/reference/RunCoxRegression.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs basic Cox Proportional Hazards regression without special options — RunCoxRegression","title":"Performs basic Cox Proportional Hazards regression without special options — RunCoxRegression","text":"RunCoxRegression uses user provided data, time/event columns, vectors specifying model, options control convergence starting position","code":""},{"path":"/reference/RunCoxRegression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs basic Cox Proportional Hazards regression without special options — RunCoxRegression","text":"","code":"RunCoxRegression(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list() )"},{"path":"/reference/RunCoxRegression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs basic Cox Proportional Hazards regression without special options — RunCoxRegression","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\")","code":""},{"path":"/reference/RunCoxRegression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs basic Cox Proportional Hazards regression without special options — RunCoxRegression","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunCoxRegression.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs basic Cox Proportional Hazards regression without special options — RunCoxRegression","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 a_n <- c(0.1, 0.1, 0.1, 0.1) keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5, \"halfmax\" = 5,   \"epsilon\" = 1e-3, \"deriv_epsilon\" = 1e-3,   \"abs_max\" = 1.0, \"change_all\" = TRUE, \"dose_abs_max\" = 100.0,   \"verbose\" = FALSE, \"ties\" = \"breslow\", \"double_step\" = 1 ) e <- RunCoxRegression(   df, time1, time2, event, names, term_n, tform,   keep_constant, a_n, modelform, fir, der_iden, control )"},{"path":"/reference/RunCoxRegression_Basic.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs basic Cox Proportional Hazards regression with a multiplicative log-linear model — RunCoxRegression_Basic","title":"Performs basic Cox Proportional Hazards regression with a multiplicative log-linear model — RunCoxRegression_Basic","text":"RunCoxRegression_Basic uses user provided data, time/event columns, vectors specifying model, options control convergence starting positions","code":""},{"path":"/reference/RunCoxRegression_Basic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs basic Cox Proportional Hazards regression with a multiplicative log-linear model — RunCoxRegression_Basic","text":"","code":"RunCoxRegression_Basic(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   names = c(\"CONST\"),   keep_constant = c(0),   a_n = c(0),   der_iden = 0,   control = list() )"},{"path":"/reference/RunCoxRegression_Basic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs basic Cox Proportional Hazards regression with a multiplicative log-linear model — RunCoxRegression_Basic","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\")","code":""},{"path":"/reference/RunCoxRegression_Basic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs basic Cox Proportional Hazards regression with a multiplicative log-linear model — RunCoxRegression_Basic","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunCoxRegression_Basic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs basic Cox Proportional Hazards regression with a multiplicative log-linear model — RunCoxRegression_Basic","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") a_n <- c(1.1, -0.1, 0.2, 0.5) # used to test at a specific point keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5, \"halfmax\" = 5,   \"epsilon\" = 1e-3, \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0,   \"change_all\" = TRUE, \"dose_abs_max\" = 100.0, \"verbose\" = FALSE,   \"ties\" = \"breslow\", \"double_step\" = 1 ) e <- RunCoxRegression_Basic(   df, time1, time2, event, names, keep_constant,   a_n, der_iden, control )"},{"path":"/reference/RunCoxRegression_CR.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs basic Cox Proportional Hazards regression with competing risks — RunCoxRegression_CR","title":"Performs basic Cox Proportional Hazards regression with competing risks — RunCoxRegression_CR","text":"RunCoxRegression_CR uses user provided data, time/event columns, vectors specifying model, options control convergence, starting positions, censoring adjustment","code":""},{"path":"/reference/RunCoxRegression_CR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs basic Cox Proportional Hazards regression with competing risks — RunCoxRegression_CR","text":"","code":"RunCoxRegression_CR(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   cens_weight = \"null\" )"},{"path":"/reference/RunCoxRegression_CR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs basic Cox Proportional Hazards regression with competing risks — RunCoxRegression_CR","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") cens_weight column containing row weights","code":""},{"path":"/reference/RunCoxRegression_CR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs basic Cox Proportional Hazards regression with competing risks — RunCoxRegression_CR","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunCoxRegression_CR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs basic Cox Proportional Hazards regression with competing risks — RunCoxRegression_CR","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 2, 1, 2, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 a_n <- c(0.1, 0.1, 0.1, 0.1) keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5,   \"halfmax\" = 5, \"epsilon\" = 1e-3,   \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE,   \"ties\" = \"breslow\", \"double_step\" = 1 ) # weights the probability that a row would continue to extend without censoring, #    for risk group calculation df$cens_weight <- c(0.83, 0.37, 0.26, 0.34, 0.55, 0.23, 0.27) # censoring weight is generated by the survival library finegray function, or by hand. # The ratio of weight at event end point to weight at row endpoint is used. e <- RunCoxRegression_CR(   df, time1, time2, event, names, term_n, tform,   keep_constant, a_n, modelform, fir, der_iden, control, \"cens_weight\" )"},{"path":"/reference/RunCoxRegression_Guesses_CPP.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs basic Cox Proportional Hazards regression, Generates multiple starting guesses on c++ side — RunCoxRegression_Guesses_CPP","title":"Performs basic Cox Proportional Hazards regression, Generates multiple starting guesses on c++ side — RunCoxRegression_Guesses_CPP","text":"RunCoxRegression_Guesses_CPP uses user provided data, time/event columns, vectors specifying model, options control convergence starting positions. additional options starting several initial guesses","code":""},{"path":"/reference/RunCoxRegression_Guesses_CPP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs basic Cox Proportional Hazards regression, Generates multiple starting guesses on c++ side — RunCoxRegression_Guesses_CPP","text":"","code":"RunCoxRegression_Guesses_CPP(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   guesses_control = list(),   strat_col = \"null\",   model_control = list(),   cens_weight = \"null\" )"},{"path":"/reference/RunCoxRegression_Guesses_CPP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs basic Cox Proportional Hazards regression, Generates multiple starting guesses on c++ side — RunCoxRegression_Guesses_CPP","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") guesses_control list parameters control guessing works, see Def_Control_Guess() options vignette(\"Control_Options\") strat_col column stratify needed model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details cens_weight column containing row weights","code":""},{"path":"/reference/RunCoxRegression_Guesses_CPP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs basic Cox Proportional Hazards regression, Generates multiple starting guesses on c++ side — RunCoxRegression_Guesses_CPP","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunCoxRegression_Guesses_CPP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs basic Cox Proportional Hazards regression, Generates multiple starting guesses on c++ side — RunCoxRegression_Guesses_CPP","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1),   \"e\" = c(0, 0, 1, 0, 0, 0, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") a_n <- c(1.1, -0.1, 0.2, 0.5) # used to test at a specific point term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5,   \"halfmax\" = 5, \"epsilon\" = 1e-3,   \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE, \"ties\" = \"breslow\",   \"double_step\" = 1 ) guesses_control <- list(   \"maxiter\" = 10, \"guesses\" = 10,   \"lin_min\" = 0.001, \"lin_max\" = 1,   \"loglin_min\" = -1, \"loglin_max\" = 1,   \"lin_method\" = \"uniform\",   \"loglin_method\" = \"uniform\", strata = FALSE ) strat_col <- \"e\" options(warn = -1) e <- RunCoxRegression_Guesses_CPP(   df, time1, time2, event, names, term_n,   tform, keep_constant, a_n, modelform, fir,   der_iden, control, guesses_control, strat_col )"},{"path":"/reference/RunCoxRegression_Omnibus.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs Cox Proportional Hazards regression using the omnibus function — RunCoxRegression_Omnibus","title":"Performs Cox Proportional Hazards regression using the omnibus function — RunCoxRegression_Omnibus","text":"RunCoxRegression_Omnibus uses user provided data, time/event columns, vectors specifying model, options control convergence starting positions. additional options starting several initial guesses, using stratification, multiplicative loglinear 1-term, competing risks, calculation without derivatives","code":""},{"path":"/reference/RunCoxRegression_Omnibus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs Cox Proportional Hazards regression using the omnibus function — RunCoxRegression_Omnibus","text":"","code":"RunCoxRegression_Omnibus(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   strat_col = \"null\",   cens_weight = \"null\",   model_control = list(),   cons_mat = as.matrix(c(0)),   cons_vec = c(0) )"},{"path":"/reference/RunCoxRegression_Omnibus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs Cox Proportional Hazards regression using the omnibus function — RunCoxRegression_Omnibus","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") strat_col column stratify needed cens_weight column containing row weights model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details cons_mat Matrix containing coefficients system linear constraints, formatted matrix cons_vec Vector containing constants system linear constraints, formatted vector","code":""},{"path":"/reference/RunCoxRegression_Omnibus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs Cox Proportional Hazards regression using the omnibus function — RunCoxRegression_Omnibus","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunCoxRegression_Omnibus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs Cox Proportional Hazards regression using the omnibus function — RunCoxRegression_Omnibus","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1),   \"e\" = c(0, 0, 1, 0, 0, 0, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") a_n <- list(c(1.1, -0.1, 0.2, 0.5), c(1.6, -0.12, 0.3, 0.4)) # used to test at a specific point term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiters\" = c(5, 5, 5),   \"halfmax\" = 5, \"epsilon\" = 1e-3, \"deriv_epsilon\" = 1e-3,   \"abs_max\" = 1.0, \"change_all\" = TRUE, \"dose_abs_max\" = 100.0,   \"verbose\" = FALSE,   \"ties\" = \"breslow\", \"double_step\" = 1, \"guesses\" = 2 ) e <- RunCoxRegression_Omnibus(df, time1, time2, event,   names, term_n, tform, keep_constant,   a_n, modelform, fir, der_iden, control,   model_control = list(     \"single\" = FALSE,     \"basic\" = FALSE, \"cr\" = FALSE, \"null\" = FALSE   ) )"},{"path":"/reference/RunCoxRegression_Omnibus_Multidose.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs Cox Proportional Hazards regression using the omnibus function with multiple column realizations — RunCoxRegression_Omnibus_Multidose","title":"Performs Cox Proportional Hazards regression using the omnibus function with multiple column realizations — RunCoxRegression_Omnibus_Multidose","text":"RunCoxRegression_Omnibus_Multidose uses user provided data, time/event columns, vectors specifying model, options control convergence starting positions. Used 2DMC column uncertainty methods. Returns optimized parameters, log-likelihood, standard deviation realization. additional options using stratification, multiplicative loglinear 1-term, competing risks, calculation without derivatives","code":""},{"path":"/reference/RunCoxRegression_Omnibus_Multidose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs Cox Proportional Hazards regression using the omnibus function with multiple column realizations — RunCoxRegression_Omnibus_Multidose","text":"","code":"RunCoxRegression_Omnibus_Multidose(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   realization_columns = matrix(c(\"temp00\", \"temp01\", \"temp10\", \"temp11\"), nrow = 2),   realization_index = c(\"temp0\", \"temp1\"),   control = list(),   strat_col = \"null\",   cens_weight = \"null\",   model_control = list(),   cons_mat = as.matrix(c(0)),   cons_vec = c(0) )"},{"path":"/reference/RunCoxRegression_Omnibus_Multidose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs Cox Proportional Hazards regression using the omnibus function with multiple column realizations — RunCoxRegression_Omnibus_Multidose","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 realization_columns used multi-realization regressions. Matrix column names rows column realizations, columns realization realization_index used multi-realization regressions. Vector column names, one column realizations. name used \"names\" variable equation definition control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") strat_col column stratify needed cens_weight column containing row weights model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details cons_mat Matrix containing coefficients system linear constraints, formatted matrix cons_vec Vector containing constants system linear constraints, formatted vector","code":""},{"path":"/reference/RunCoxRegression_Omnibus_Multidose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs Cox Proportional Hazards regression using the omnibus function with multiple column realizations — RunCoxRegression_Omnibus_Multidose","text":"returns list final results realization","code":""},{"path":[]},{"path":"/reference/RunCoxRegression_Omnibus_Multidose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs Cox Proportional Hazards regression using the omnibus function with multiple column realizations — RunCoxRegression_Omnibus_Multidose","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"t0\" = c(18, 20, 18, 19, 21, 20, 18),   \"t1\" = c(30, 45, 57, 47, 36, 60, 55),   \"lung\" = c(0, 0, 1, 0, 1, 0, 0),   \"dose\" = c(0, 1, 1, 0, 1, 0, 1) ) set.seed(3742) df$rand <- floor(runif(nrow(df), min = 0, max = 5)) df$rand0 <- floor(runif(nrow(df), min = 0, max = 5)) df$rand1 <- floor(runif(nrow(df), min = 0, max = 5)) df$rand2 <- floor(runif(nrow(df), min = 0, max = 5)) time1 <- \"t0\" time2 <- \"t1\" names <- c(\"dose\", \"rand\") term_n <- c(0, 0) tform <- c(\"loglin\", \"loglin\") realization_columns <- matrix(c(\"rand0\", \"rand1\", \"rand2\"), nrow = 1) realization_index <- c(\"rand\") keep_constant <- c(1, 0) a_n <- c(0, 0) modelform <- \"M\" fir <- 0 der_iden <- 0 cens_weight <- c(0) event <- \"lung\" a_n <- c(-0.1, -0.1) keep_constant <- c(0, 0) control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 1,   \"halfmax\" = 2, \"epsilon\" = 1e-6,   \"deriv_epsilon\" = 1e-6, \"abs_max\" = 1.0,   \"change_all\" = TRUE, \"dose_abs_max\" = 100.0,   \"verbose\" = 0, \"ties\" = \"breslow\", \"double_step\" = 1 ) e <- RunCoxRegression_Omnibus_Multidose(df, time1, time2, event,   names,   term_n = term_n, tform = tform,   keep_constant = keep_constant, a_n = a_n,   modelform = modelform, fir = fir, der_iden = der_iden,   realization_columns = realization_columns,   realization_index = realization_index,   control = control, strat_col = \"fac\",   model_control = list(), cens_weight = \"null\" )"},{"path":"/reference/RunCoxRegression_Single.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs basic Cox Proportional Hazards calculation with no derivative — RunCoxRegression_Single","title":"Performs basic Cox Proportional Hazards calculation with no derivative — RunCoxRegression_Single","text":"RunCoxRegression_Single uses user provided data, time/event columns, vectors specifying model, options returns log-likelihood","code":""},{"path":"/reference/RunCoxRegression_Single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs basic Cox Proportional Hazards calculation with no derivative — RunCoxRegression_Single","text":"","code":"RunCoxRegression_Single(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   control = list() )"},{"path":"/reference/RunCoxRegression_Single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs basic Cox Proportional Hazards calculation with no derivative — RunCoxRegression_Single","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\")","code":""},{"path":"/reference/RunCoxRegression_Single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs basic Cox Proportional Hazards calculation with no derivative — RunCoxRegression_Single","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunCoxRegression_Single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs basic Cox Proportional Hazards calculation with no derivative — RunCoxRegression_Single","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 a_n <- c(1.1, -0.1, 0.2, 0.5) # used to test at a specific point keep_constant <- c(0, 0, 0, 0) control <- list(   \"ncores\" = 2, \"verbose\" = FALSE,   \"ties\" = \"breslow\", \"double_step\" = 1 ) e <- RunCoxRegression_Single(   df, time1, time2, event, names, term_n, tform,   keep_constant, a_n, modelform, fir, control )"},{"path":"/reference/RunCoxRegression_Strata.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs basic Cox Proportional Hazards regression with strata effect — RunCoxRegression_Strata","title":"Performs basic Cox Proportional Hazards regression with strata effect — RunCoxRegression_Strata","text":"RunCoxRegression_Strata uses user provided data, time/event columns, vectors specifying model, options control convergence starting positions","code":""},{"path":"/reference/RunCoxRegression_Strata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs basic Cox Proportional Hazards regression with strata effect — RunCoxRegression_Strata","text":"","code":"RunCoxRegression_Strata(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   strat_col = \"null\" )"},{"path":"/reference/RunCoxRegression_Strata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs basic Cox Proportional Hazards regression with strata effect — RunCoxRegression_Strata","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") strat_col column stratify needed","code":""},{"path":"/reference/RunCoxRegression_Strata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs basic Cox Proportional Hazards regression with strata effect — RunCoxRegression_Strata","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunCoxRegression_Strata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs basic Cox Proportional Hazards regression with strata effect — RunCoxRegression_Strata","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1),   \"e\" = c(0, 0, 0, 0, 1, 0, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") a_n <- c(1.1, -0.1, 0.2, 0.5) # used to test at a specific point term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5, \"halfmax\" = 5,   \"epsilon\" = 1e-3, \"deriv_epsilon\" = 1e-3,   \"abs_max\" = 1.0, \"change_all\" = TRUE, \"dose_abs_max\" = 100.0,   \"verbose\" = FALSE, \"ties\" = \"breslow\", \"double_step\" = 1 ) strat_col <- \"e\" e <- RunCoxRegression_Strata(   df, time1, time2, event, names, term_n,   tform, keep_constant, a_n, modelform,   fir, der_iden, control, strat_col )"},{"path":"/reference/RunCoxRegression_Tier_Guesses.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs basic cox regression, with multiple guesses, starts with solving for a single term — RunCoxRegression_Tier_Guesses","title":"Performs basic cox regression, with multiple guesses, starts with solving for a single term — RunCoxRegression_Tier_Guesses","text":"RunCoxRegression_Tier_Guesses uses user provided data, time/event columns, vectors specifying model, options control convergence starting positions, additional guesses","code":""},{"path":"/reference/RunCoxRegression_Tier_Guesses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs basic cox regression, with multiple guesses, starts with solving for a single term — RunCoxRegression_Tier_Guesses","text":"","code":"RunCoxRegression_Tier_Guesses(   df,   time1 = \"%trunc%\",   time2 = \"%trunc%\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   guesses_control = list(),   strat_col = \"null\",   model_control = list(),   cens_weight = \"null\" )"},{"path":"/reference/RunCoxRegression_Tier_Guesses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs basic cox regression, with multiple guesses, starts with solving for a single term — RunCoxRegression_Tier_Guesses","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") guesses_control list parameters control guessing works, see Def_Control_Guess() options vignette(\"Control_Options\") strat_col column stratify needed model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details cens_weight column containing row weights","code":""},{"path":"/reference/RunCoxRegression_Tier_Guesses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs basic cox regression, with multiple guesses, starts with solving for a single term — RunCoxRegression_Tier_Guesses","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunCoxRegression_Tier_Guesses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs basic cox regression, with multiple guesses, starts with solving for a single term — RunCoxRegression_Tier_Guesses","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1),   \"e\" = c(0, 0, 0, 0, 1, 0, 1) ) # For the interval case time1 <- \"Starting_Age\" time2 <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") a_n <- c(1.1, -0.1, 0.2, 0.5) # used to test at a specific point term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5, \"halfmax\" = 5,   \"epsilon\" = 1e-3, \"deriv_epsilon\" = 1e-3,   \"abs_max\" = 1.0, \"change_all\" = TRUE, \"dose_abs_max\" = 100.0,   \"verbose\" = FALSE, \"ties\" = \"breslow\", \"double_step\" = 1 ) guesses_control <- list(   \"iterations\" = 10, \"guesses\" = 10, \"lin_min\" = 0.001,   \"lin_max\" = 1, \"loglin_min\" = -1, \"loglin_max\" = 1, \"lin_method\" = \"uniform\",   \"loglin_method\" = \"uniform\", strata = TRUE, term_initial = c(0, 1) ) strat_col <- \"e\" options(warn = -1) e <- RunCoxRegression_Tier_Guesses(   df, time1, time2, event, names,   term_n, tform, keep_constant,   a_n, modelform, fir, der_iden,   control, guesses_control,   strat_col )"},{"path":"/reference/RunPoissonEventAssignment.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicts how many events are due to baseline vs excess — RunPoissonEventAssignment","title":"Predicts how many events are due to baseline vs excess — RunPoissonEventAssignment","text":"RunPoissonEventAssignment uses user provided data, person-year/event columns, vectors specifying model, options calculate background excess events","code":""},{"path":"/reference/RunPoissonEventAssignment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicts how many events are due to baseline vs excess — RunPoissonEventAssignment","text":"","code":"RunPoissonEventAssignment(   df,   pyr0 = \"pyr\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   strat_col = \"null\",   model_control = list() )"},{"path":"/reference/RunPoissonEventAssignment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predicts how many events are due to baseline vs excess — RunPoissonEventAssignment","text":"df data.table containing columns interest pyr0 column used person-years per row event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") strat_col column stratify needed model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details","code":""},{"path":"/reference/RunPoissonEventAssignment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predicts how many events are due to baseline vs excess — RunPoissonEventAssignment","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunPoissonEventAssignment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predicts how many events are due to baseline vs excess — RunPoissonEventAssignment","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1) ) # For the interval case df$pyr <- df$Ending_Age - df$Starting_Age pyr <- \"pyr\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 a_n <- c(0.1, 0.1, 0.1, 0.1) keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5,   \"halfmax\" = 5, \"epsilon\" = 1e-3,   \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE, \"double_step\" = 1 ) e <- RunPoissonEventAssignment(   df, pyr, event, names, term_n,   tform, keep_constant,   a_n, modelform, fir, der_iden, control )"},{"path":"/reference/RunPoissonEventAssignment_bound.html","id":null,"dir":"Reference","previous_headings":"","what":"Predicts how many events are due to baseline vs excess at the confidence bounds of a single parameter — RunPoissonEventAssignment_bound","title":"Predicts how many events are due to baseline vs excess at the confidence bounds of a single parameter — RunPoissonEventAssignment_bound","text":"RunPoissonEventAssignment_bound uses user provided data, results poisson regression, options calculate background excess events","code":""},{"path":"/reference/RunPoissonEventAssignment_bound.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predicts how many events are due to baseline vs excess at the confidence bounds of a single parameter — RunPoissonEventAssignment_bound","text":"","code":"RunPoissonEventAssignment_bound(   df,   pyr0 = \"pyr\",   event0 = \"event\",   alternative_model = list(),   keep_constant = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   check_num = 1,   z = 2,   control = list(),   strat_col = \"null\",   model_control = list() )"},{"path":"/reference/RunPoissonEventAssignment_bound.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predicts how many events are due to baseline vs excess at the confidence bounds of a single parameter — RunPoissonEventAssignment_bound","text":"df data.table containing columns interest pyr0 column used person-years per row event0 column used event status alternative_model new model interest list form, output poisson regression keep_constant binary values denote parameters change modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 check_num parameter number check bounds , indexed 1 using order returned Colossus z Z score use confidence interval control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") strat_col column stratify needed model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details","code":""},{"path":"/reference/RunPoissonEventAssignment_bound.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predicts how many events are due to baseline vs excess at the confidence bounds of a single parameter — RunPoissonEventAssignment_bound","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunPoissonEventAssignment_bound.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predicts how many events are due to baseline vs excess at the confidence bounds of a single parameter — RunPoissonEventAssignment_bound","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1),   \"e\" = c(0, 0, 1, 0, 0, 0, 1) ) # For the interval case pyr <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") a_n <- c(1.1, -0.1, 0.2, 0.5) # used to test at a specific point term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5, \"halfmax\" = 5, \"epsilon\" = 1e-3,   \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE, \"ties\" = \"breslow\",   \"double_step\" = 1 ) guesses_control <- list(   \"maxiter\" = 10, \"guesses\" = 10, \"lin_min\" = 0.001,   \"lin_max\" = 1, \"loglin_min\" = -1, \"loglin_max\" = 1, \"lin_method\" = \"uniform\",   \"loglin_method\" = \"uniform\", strata = FALSE ) strat_col <- \"e\" e0 <- RunPoissonRegression_Omnibus(   df, pyr, event, names, term_n, tform,   keep_constant,   a_n, modelform, fir, der_iden,   control, strat_col ) e <- RunPoissonEventAssignment_bound(   df, pyr, event, e0, keep_constant,   modelform, fir, der_iden, 4, 2, control )"},{"path":"/reference/RunPoissonRegression.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs basic poisson regression — RunPoissonRegression","title":"Performs basic poisson regression — RunPoissonRegression","text":"RunPoissonRegression uses user provided data, person-year/event columns, vectors specifying model, options control convergence starting positions special options","code":""},{"path":"/reference/RunPoissonRegression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs basic poisson regression — RunPoissonRegression","text":"","code":"RunPoissonRegression(   df,   pyr0 = \"pyr\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list() )"},{"path":"/reference/RunPoissonRegression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs basic poisson regression — RunPoissonRegression","text":"df data.table containing columns interest pyr0 column used person-years per row event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\")","code":""},{"path":"/reference/RunPoissonRegression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs basic poisson regression — RunPoissonRegression","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunPoissonRegression.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs basic poisson regression — RunPoissonRegression","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1) ) # For the interval case df$pyr <- df$Ending_Age - df$Starting_Age pyr <- \"pyr\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 a_n <- c(0.1, 0.1, 0.1, 0.1) keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5,   \"halfmax\" = 5, \"epsilon\" = 1e-3,   \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE, \"double_step\" = 1 ) e <- RunPoissonRegression(   df, pyr, event, names, term_n, tform,   keep_constant,   a_n, modelform, fir, der_iden, control )"},{"path":"/reference/RunPoissonRegression_Guesses_CPP.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs basic Poisson regression, generates multiple starting guesses on c++ side — RunPoissonRegression_Guesses_CPP","title":"Performs basic Poisson regression, generates multiple starting guesses on c++ side — RunPoissonRegression_Guesses_CPP","text":"RunPoissonRegression_Guesses_CPP uses user provided data, time/event columns, vectors specifying model, options control convergence starting positions. additional options starting several initial guesses","code":""},{"path":"/reference/RunPoissonRegression_Guesses_CPP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs basic Poisson regression, generates multiple starting guesses on c++ side — RunPoissonRegression_Guesses_CPP","text":"","code":"RunPoissonRegression_Guesses_CPP(   df,   pyr0 = \"pyr\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   guesses_control = list(),   strat_col = \"null\",   model_control = list() )"},{"path":"/reference/RunPoissonRegression_Guesses_CPP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs basic Poisson regression, generates multiple starting guesses on c++ side — RunPoissonRegression_Guesses_CPP","text":"df data.table containing columns interest pyr0 column used person-years per row event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") guesses_control list parameters control guessing works, see Def_Control_Guess() options vignette(\"Control_Options\") strat_col column stratify needed model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details","code":""},{"path":"/reference/RunPoissonRegression_Guesses_CPP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs basic Poisson regression, generates multiple starting guesses on c++ side — RunPoissonRegression_Guesses_CPP","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunPoissonRegression_Guesses_CPP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs basic Poisson regression, generates multiple starting guesses on c++ side — RunPoissonRegression_Guesses_CPP","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1),   \"e\" = c(0, 0, 1, 0, 0, 0, 1) ) # For the interval case pyr <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") a_n <- c(1.1, -0.1, 0.2, 0.5) # used to test at a specific point term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5,   \"halfmax\" = 5, \"epsilon\" = 1e-3,   \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE, \"ties\" = \"breslow\",   \"double_step\" = 1 ) guesses_control <- list(   \"maxiter\" = 10, \"guesses\" = 10,   \"lin_min\" = 0.001, \"lin_max\" = 1,   \"loglin_min\" = -1, \"loglin_max\" = 1, \"lin_method\" = \"uniform\",   \"loglin_method\" = \"uniform\", strata = FALSE ) strat_col <- \"e\" options(warn = -1) e <- RunPoissonRegression_Guesses_CPP(   df, pyr, event, names, term_n,   tform, keep_constant, a_n, modelform, fir,   der_iden, control, guesses_control, strat_col )"},{"path":"/reference/RunPoissonRegression_Joint_Omnibus.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs joint Poisson regression using the omnibus function — RunPoissonRegression_Joint_Omnibus","title":"Performs joint Poisson regression using the omnibus function — RunPoissonRegression_Joint_Omnibus","text":"RunPoissonRegression_Joint_Omnibus uses user provided data, time/event columns, vectors specifying model, options control convergence starting positions. additional options starting several initial guesses, uses joint competing risks equation","code":""},{"path":"/reference/RunPoissonRegression_Joint_Omnibus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs joint Poisson regression using the omnibus function — RunPoissonRegression_Joint_Omnibus","text":"","code":"RunPoissonRegression_Joint_Omnibus(   df,   pyr0,   events,   name_list,   term_n_list = list(),   tform_list = list(),   keep_constant_list = list(),   a_n_list = list(),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   strat_col = \"null\",   model_control = list(),   cons_mat = as.matrix(c(0)),   cons_vec = c(0) )"},{"path":"/reference/RunPoissonRegression_Joint_Omnibus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs joint Poisson regression using the omnibus function — RunPoissonRegression_Joint_Omnibus","text":"df data.table containing columns interest pyr0 column used person-years per row events vector event column names name_list list vectors columns event specific shared model elements, required term_n_list list vectors term numbers event specific shared model elements, defaults term 0 tform_list list vectors subterm types event specific shared model elements, defaults loglinear keep_constant_list list vectors constant elements event specific shared model elements, defaults free (0) a_n_list list vectors parameter values event specific shared model elements, defaults term 0 modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") strat_col column stratify needed model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details cons_mat Matrix containing coefficients system linear constraints, formatted matrix cons_vec Vector containing constants system linear constraints, formatted vector","code":""},{"path":"/reference/RunPoissonRegression_Joint_Omnibus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs joint Poisson regression using the omnibus function — RunPoissonRegression_Joint_Omnibus","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunPoissonRegression_Joint_Omnibus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs joint Poisson regression using the omnibus function — RunPoissonRegression_Joint_Omnibus","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette a <- c(0, 0, 0, 1, 1, 1) b <- c(1, 1, 1, 2, 2, 2) c <- c(0, 1, 2, 2, 1, 0) d <- c(1, 1, 0, 0, 1, 1) e <- c(0, 1, 1, 1, 0, 0) f <- c(0, 1, 0, 0, 1, 1) df <- data.table(\"t0\" = a, \"t1\" = b, \"e0\" = c, \"e1\" = d, \"fac\" = e) time1 <- \"t0\" time2 <- \"t1\" df$pyr <- df$t1 - df$t0 pyr <- \"pyr\" events <- c(\"e0\", \"e1\") names_e0 <- c(\"fac\") names_e1 <- c(\"fac\") names_shared <- c(\"t0\", \"t0\") term_n_e0 <- c(0) term_n_e1 <- c(0) term_n_shared <- c(0, 0) tform_e0 <- c(\"loglin\") tform_e1 <- c(\"loglin\") tform_shared <- c(\"quad_slope\", \"loglin_top\") keep_constant_e0 <- c(0) keep_constant_e1 <- c(0) keep_constant_shared <- c(0, 0) a_n_e0 <- c(-0.1) a_n_e1 <- c(0.1) a_n_shared <- c(0.001, -0.02) name_list <- list(\"shared\" = names_shared, \"e0\" = names_e0, \"e1\" = names_e1) term_n_list <- list(\"shared\" = term_n_shared, \"e0\" = term_n_e0, \"e1\" = term_n_e1) tform_list <- list(\"shared\" = tform_shared, \"e0\" = tform_e0, \"e1\" = tform_e1) keep_constant_list <- list(   \"shared\" = keep_constant_shared,   \"e0\" = keep_constant_e0, \"e1\" = keep_constant_e1 ) a_n_list <- list(\"shared\" = a_n_shared, \"e0\" = a_n_e0, \"e1\" = a_n_e1) der_iden <- 0 modelform <- \"M\" fir <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5,   \"halfmax\" = 5, \"epsilon\" = 1e-3,   \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE,   \"ties\" = \"breslow\", \"double_step\" = 1 ) guesses_control <- list(   \"maxiter\" = 10, \"guesses\" = 10,   \"lin_min\" = 0.001, \"lin_max\" = 1,   \"loglin_min\" = -1, \"loglin_max\" = 1, \"lin_method\" = \"uniform\",   \"loglin_method\" = \"uniform\", strata = FALSE ) strat_col <- \"f\" e <- RunPoissonRegression_Joint_Omnibus(   df, pyr, events, name_list,   term_n_list,   tform_list, keep_constant_list,   a_n_list,   modelform, fir, der_iden,   control, strat_col )"},{"path":"/reference/RunPoissonRegression_Omnibus.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs basic Poisson regression using the omnibus function — RunPoissonRegression_Omnibus","title":"Performs basic Poisson regression using the omnibus function — RunPoissonRegression_Omnibus","text":"RunPoissonRegression_Omnibus uses user provided data, time/event columns, vectors specifying model, options control convergence starting positions. additional options starting several initial guesses","code":""},{"path":"/reference/RunPoissonRegression_Omnibus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs basic Poisson regression using the omnibus function — RunPoissonRegression_Omnibus","text":"","code":"RunPoissonRegression_Omnibus(   df,   pyr0 = \"pyr\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   strat_col = \"null\",   model_control = list(),   cons_mat = as.matrix(c(0)),   cons_vec = c(0) )"},{"path":"/reference/RunPoissonRegression_Omnibus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs basic Poisson regression using the omnibus function — RunPoissonRegression_Omnibus","text":"df data.table containing columns interest pyr0 column used person-years per row event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") strat_col column stratify needed model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details cons_mat Matrix containing coefficients system linear constraints, formatted matrix cons_vec Vector containing constants system linear constraints, formatted vector","code":""},{"path":"/reference/RunPoissonRegression_Omnibus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs basic Poisson regression using the omnibus function — RunPoissonRegression_Omnibus","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunPoissonRegression_Omnibus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs basic Poisson regression using the omnibus function — RunPoissonRegression_Omnibus","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1),   \"e\" = c(0, 0, 1, 0, 0, 0, 1) ) # For the interval case pyr <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") a_n <- c(1.1, -0.1, 0.2, 0.5) # used to test at a specific point term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5,   \"halfmax\" = 5, \"epsilon\" = 1e-3,   \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE, \"ties\" = \"breslow\",   \"double_step\" = 1 ) guesses_control <- list(   \"maxiter\" = 10, \"guesses\" = 10, \"lin_min\" = 0.001,   \"lin_max\" = 1, \"loglin_min\" = -1, \"loglin_max\" = 1, \"lin_method\" = \"uniform\",   \"loglin_method\" = \"uniform\", strata = FALSE ) strat_col <- \"e\" e <- RunPoissonRegression_Omnibus(   df, pyr, event, names, term_n,   tform, keep_constant,   a_n, modelform, fir, der_iden,   control, strat_col )"},{"path":"/reference/RunPoissonRegression_Residual.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates poisson residuals — RunPoissonRegression_Residual","title":"Calculates poisson residuals — RunPoissonRegression_Residual","text":"RunPoissonRegression_Residual uses user provided data, time/event columns, vectors specifying model, options. Calculates residuals sum residuals","code":""},{"path":"/reference/RunPoissonRegression_Residual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates poisson residuals — RunPoissonRegression_Residual","text":"","code":"RunPoissonRegression_Residual(   df,   pyr0 = \"pyr\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   strat_col = \"null\",   model_control = list() )"},{"path":"/reference/RunPoissonRegression_Residual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates poisson residuals — RunPoissonRegression_Residual","text":"df data.table containing columns interest pyr0 column used person-years per row event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") strat_col column stratify needed model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details","code":""},{"path":"/reference/RunPoissonRegression_Residual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates poisson residuals — RunPoissonRegression_Residual","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunPoissonRegression_Residual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates poisson residuals — RunPoissonRegression_Residual","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1),   \"e\" = c(0, 0, 1, 0, 0, 0, 1) ) # For the interval case pyr <- \"Ending_Age\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") a_n <- c(1.1, -0.1, 0.2, 0.5) # used to test at a specific point term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5,   \"halfmax\" = 5, \"epsilon\" = 1e-3,   \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE, \"ties\" = \"breslow\",   \"double_step\" = 1 ) guesses_control <- list(   \"maxiter\" = 10, \"guesses\" = 10,   \"lin_min\" = 0.001, \"lin_max\" = 1,   \"loglin_min\" = -1, \"loglin_max\" = 1, \"lin_method\" = \"uniform\",   \"loglin_method\" = \"uniform\", strata = FALSE ) strat_col <- \"e\" e <- RunPoissonRegression_Residual(   df, pyr, event, names, term_n,   tform, keep_constant,   a_n, modelform, fir, der_iden,   control, strat_col )"},{"path":"/reference/RunPoissonRegression_Single.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs poisson regression with no derivative calculations — RunPoissonRegression_Single","title":"Performs poisson regression with no derivative calculations — RunPoissonRegression_Single","text":"RunPoissonRegression_Single uses user provided data, person-year/event columns, vectors specifying model, returns results","code":""},{"path":"/reference/RunPoissonRegression_Single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs poisson regression with no derivative calculations — RunPoissonRegression_Single","text":"","code":"RunPoissonRegression_Single(   df,   pyr0 = \"pyr\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   a_n = c(0),   modelform = \"M\",   fir = 0,   control = list(),   keep_constant = rep(0, length(names)) )"},{"path":"/reference/RunPoissonRegression_Single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs poisson regression with no derivative calculations — RunPoissonRegression_Single","text":"df data.table containing columns interest pyr0 column used person-years per row event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") keep_constant binary values denote parameters change","code":""},{"path":"/reference/RunPoissonRegression_Single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs poisson regression with no derivative calculations — RunPoissonRegression_Single","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunPoissonRegression_Single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs poisson regression with no derivative calculations — RunPoissonRegression_Single","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1) ) # For the interval case df$pyr <- df$Ending_Age - df$Starting_Age pyr <- \"pyr\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 a_n <- c(0.1, 0.1, 0.1, 0.1) keep_constant <- c(0, 0, 0, 0) control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5, \"halfmax\" = 5,   \"epsilon\" = 1e-3, \"deriv_epsilon\" = 1e-3,   \"abs_max\" = 1.0, \"change_all\" = TRUE, \"dose_abs_max\" = 100.0,   \"verbose\" = FALSE, \"double_step\" = 1 ) e <- RunPoissonRegression_Single(   df, pyr, event, names,   term_n, tform, a_n, modelform,   fir, control )"},{"path":"/reference/RunPoissonRegression_Strata.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs poisson regression with strata effect — RunPoissonRegression_Strata","title":"Performs poisson regression with strata effect — RunPoissonRegression_Strata","text":"RunPoissonRegression_Strata uses user provided data, time/event columns, vectors specifying model, options control convergence starting positions","code":""},{"path":"/reference/RunPoissonRegression_Strata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs poisson regression with strata effect — RunPoissonRegression_Strata","text":"","code":"RunPoissonRegression_Strata(   df,   pyr0 = \"pyr\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   strat_col = \"null\" )"},{"path":"/reference/RunPoissonRegression_Strata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs poisson regression with strata effect — RunPoissonRegression_Strata","text":"df data.table containing columns interest pyr0 column used person-years per row event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") strat_col column stratify needed","code":""},{"path":"/reference/RunPoissonRegression_Strata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs poisson regression with strata effect — RunPoissonRegression_Strata","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunPoissonRegression_Strata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs poisson regression with strata effect — RunPoissonRegression_Strata","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1),   \"e\" = c(0, 0, 0, 0, 1, 0, 1) ) # For the interval case df$pyr <- df$Ending_Age - df$Starting_Age pyr <- \"pyr\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 a_n <- c(0.1, 0.1, 0.1, 0.1) keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5, \"halfmax\" = 5,   \"epsilon\" = 1e-3, \"deriv_epsilon\" = 1e-3,   \"abs_max\" = 1.0, \"change_all\" = TRUE, \"dose_abs_max\" = 100.0,   \"verbose\" = FALSE, \"double_step\" = 1 ) strat_col <- c(\"e\") e <- RunPoissonRegression_Strata(   df, pyr, event, names,   term_n, tform, keep_constant,   a_n, modelform, fir, der_iden, control, strat_col )"},{"path":"/reference/RunPoissonRegression_Tier_Guesses.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs basic poisson regression, with multiple guesses, starts with a single term — RunPoissonRegression_Tier_Guesses","title":"Performs basic poisson regression, with multiple guesses, starts with a single term — RunPoissonRegression_Tier_Guesses","text":"RunPoissonRegression_Tier_Guesses uses user provided data, time/event columns, vectors specifying model, options control convergence starting positions, additional guesses","code":""},{"path":"/reference/RunPoissonRegression_Tier_Guesses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs basic poisson regression, with multiple guesses, starts with a single term — RunPoissonRegression_Tier_Guesses","text":"","code":"RunPoissonRegression_Tier_Guesses(   df,   pyr0 = \"pyr\",   event0 = \"event\",   names = c(\"CONST\"),   term_n = c(0),   tform = \"loglin\",   keep_constant = c(0),   a_n = c(0),   modelform = \"M\",   fir = 0,   der_iden = 0,   control = list(),   guesses_control = list(),   strat_col = \"null\",   model_control = list() )"},{"path":"/reference/RunPoissonRegression_Tier_Guesses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs basic poisson regression, with multiple guesses, starts with a single term — RunPoissonRegression_Tier_Guesses","text":"df data.table containing columns interest pyr0 column used person-years per row event0 column used event status names columns elements model, used identify data columns term_n term numbers element model tform list string function identifiers, used linear/step keep_constant binary values denote parameters change a_n list initial parameter values, used determine number parameters. May either list vectors single vector. modelform string specifying model type: M, , , PA, PAE, GMIX, GMIX-R, GMIX-E fir term number initial term, used models form T0*f(Ti) order matters der_iden number subterm test derivative , used testing runs single varying parameter, smaller total number parameters. indexed starting 0 control list parameters controlling convergence, see Def_Control() options vignette(\"Control_Options\") guesses_control list parameters control guessing works, see Def_Control_Guess() options vignette(\"Control_Options\") strat_col column stratify needed model_control controls alternative model options used, see Def_model_control() options vignette(\"Control_Options\") details","code":""},{"path":"/reference/RunPoissonRegression_Tier_Guesses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs basic poisson regression, with multiple guesses, starts with a single term — RunPoissonRegression_Tier_Guesses","text":"returns list final results","code":""},{"path":[]},{"path":"/reference/RunPoissonRegression_Tier_Guesses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs basic poisson regression, with multiple guesses, starts with a single term — RunPoissonRegression_Tier_Guesses","text":"","code":"library(data.table) ## basic example code reproduced from the starting-description vignette df <- data.table::data.table(   \"UserID\" = c(112, 114, 213, 214, 115, 116, 117),   \"Starting_Age\" = c(18, 20, 18, 19, 21, 20, 18),   \"Ending_Age\" = c(30, 45, 57, 47, 36, 60, 55),   \"Cancer_Status\" = c(0, 0, 1, 0, 1, 0, 0),   \"a\" = c(0, 1, 1, 0, 1, 0, 1),   \"b\" = c(1, 1.1, 2.1, 2, 0.1, 1, 0.2),   \"c\" = c(10, 11, 10, 11, 12, 9, 11),   \"d\" = c(0, 0, 0, 1, 1, 1, 1),   \"e\" = c(0, 0, 0, 0, 1, 0, 1) ) # For the interval case df$pyr <- df$Ending_Age - df$Starting_Age pyr <- \"pyr\" event <- \"Cancer_Status\" names <- c(\"a\", \"b\", \"c\", \"d\") a_n <- c(1.1, -0.1, 0.2, 0.5) # used to test at a specific point term_n <- c(0, 1, 1, 2) tform <- c(\"loglin\", \"lin\", \"lin\", \"plin\") modelform <- \"M\" fir <- 0 keep_constant <- c(0, 0, 0, 0) der_iden <- 0 control <- list(   \"ncores\" = 2, \"lr\" = 0.75, \"maxiter\" = 5,   \"halfmax\" = 5, \"epsilon\" = 1e-3,   \"deriv_epsilon\" = 1e-3, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0, \"verbose\" = FALSE, \"double_step\" = 1 ) guesses_control <- list(   \"iterations\" = 10, \"guesses\" = 10,   \"lin_min\" = 0.001, \"lin_max\" = 1,   \"loglin_min\" = -1, \"loglin_max\" = 1, \"lin_method\" = \"uniform\",   \"loglin_method\" = \"uniform\", strata = TRUE, term_initial = c(0, 1) ) strat_col <- c(\"e\") options(warn = -1) e <- RunPoissonRegression_Tier_Guesses(   df, pyr, event, names,   term_n, tform, keep_constant, a_n, modelform,   fir, der_iden, control, guesses_control, strat_col )"},{"path":"/reference/System_Version.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks OS, compilers, and OMP — System_Version","title":"Checks OS, compilers, and OMP — System_Version","text":"System_Version checks OS, default R c++ compiler, OMP enabled","code":""},{"path":"/reference/System_Version.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks OS, compilers, and OMP — System_Version","text":"","code":"System_Version()"},{"path":"/reference/System_Version.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks OS, compilers, and OMP — System_Version","text":"returns list results","code":""},{"path":[]},{"path":"/reference/Time_Since.html","id":null,"dir":"Reference","previous_headings":"","what":"Automates creating a date since a reference column — Time_Since","title":"Automates creating a date since a reference column — Time_Since","text":"Time_Since generates new dataframe column containing time since reference given unit","code":""},{"path":"/reference/Time_Since.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automates creating a date since a reference column — Time_Since","text":"","code":"Time_Since(df, dcol0, tref, col_name, units = \"days\")"},{"path":"/reference/Time_Since.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automates creating a date since a reference column — Time_Since","text":"df data.table containing columns interest dcol0 list ending month, day, year tref reference time date format col_name vector new column names units time unit use","code":""},{"path":"/reference/Time_Since.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automates creating a date since a reference column — Time_Since","text":"returns updated dataframe","code":""},{"path":[]},{"path":"/reference/Time_Since.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automates creating a date since a reference column — Time_Since","text":"","code":"library(data.table) m0 <- c(1, 1, 2, 2) m1 <- c(2, 2, 3, 3) d0 <- c(1, 2, 3, 4) d1 <- c(6, 7, 8, 9) y0 <- c(1990, 1991, 1997, 1998) y1 <- c(2001, 2003, 2005, 2006) df <- data.table::data.table(   \"m0\" = m0, \"m1\" = m1,   \"d0\" = d0, \"d1\" = d1,   \"y0\" = y0, \"y1\" = y1 ) tref <- strptime(\"3-22-1997\", format = \"%m-%d-%Y\", tz = \"UTC\") df <- Time_Since(df, c(\"m1\", \"d1\", \"y1\"), tref, \"date_since\")"},{"path":"/reference/factorize.html","id":null,"dir":"Reference","previous_headings":"","what":"Splits a parameter into factors — factorize","title":"Splits a parameter into factors — factorize","text":"factorize uses user provided list columns define new parameter unique value update data.table. interaction terms","code":""},{"path":"/reference/factorize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Splits a parameter into factors — factorize","text":"","code":"factorize(df, col_list, verbose = 0)"},{"path":"/reference/factorize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Splits a parameter into factors — factorize","text":"df data.table containing columns interest col_list array column names factor terms defined verbose integer valued 0-4 controlling information printed terminal. level includes lower levels. 0: silent, 1: errors printed, 2: warnings printed, 3: notes printed, 4: debug information printed. Errors situations stop regression, warnings situations assume default values user might intended, notes provide information regression progress, debug prints C++ progress intermediate results. default level 2 True/False converted 3/0.","code":""},{"path":"/reference/factorize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Splits a parameter into factors — factorize","text":"returns list two named fields. df updated dataframe, cols new column names","code":""},{"path":[]},{"path":"/reference/factorize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Splits a parameter into factors — factorize","text":"","code":"library(data.table) a <- c(0, 1, 2, 3, 4, 5, 6) b <- c(1, 2, 3, 4, 5, 6, 7) c <- c(0, 1, 2, 1, 0, 1, 0) df <- data.table::data.table(\"a\" = a, \"b\" = b, \"c\" = c) col_list <- c(\"c\") val <- factorize(df, col_list) df <- val$df new_col <- val$cols"},{"path":"/reference/factorize_par.html","id":null,"dir":"Reference","previous_headings":"","what":"Splits a parameter into factors in parallel — factorize_par","title":"Splits a parameter into factors in parallel — factorize_par","text":"factorize_par uses user provided list columns define new parameter unique value update data.table. interaction terms","code":""},{"path":"/reference/factorize_par.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Splits a parameter into factors in parallel — factorize_par","text":"","code":"factorize_par(df, col_list, verbose = 0, nthreads = as.numeric(detectCores()))"},{"path":"/reference/factorize_par.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Splits a parameter into factors in parallel — factorize_par","text":"df data.table containing columns interest col_list array column names factor terms defined verbose integer valued 0-4 controlling information printed terminal. level includes lower levels. 0: silent, 1: errors printed, 2: warnings printed, 3: notes printed, 4: debug information printed. Errors situations stop regression, warnings situations assume default values user might intended, notes provide information regression progress, debug prints C++ progress intermediate results. default level 2 True/False converted 3/0. nthreads number threads use, use threads available machine","code":""},{"path":"/reference/factorize_par.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Splits a parameter into factors in parallel — factorize_par","text":"returns list two named fields. df updated dataframe, cols new column names","code":""},{"path":[]},{"path":"/reference/factorize_par.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Splits a parameter into factors in parallel — factorize_par","text":"","code":"library(data.table) a <- c(0, 1, 2, 3, 4, 5, 6) b <- c(1, 2, 3, 4, 5, 6, 7) c <- c(0, 1, 2, 1, 0, 1, 0) df <- data.table::data.table(\"a\" = a, \"b\" = b, \"c\" = c) col_list <- c(\"c\") val <- factorize_par(df, col_list, FALSE, 2) df <- val$df new_col <- val$cols"},{"path":"/reference/gcc_version.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks default c++ compiler — gcc_version","title":"Checks default c++ compiler — gcc_version","text":"gcc_version Checks default c++ compiler, part configuration script","code":""},{"path":"/reference/gcc_version.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks default c++ compiler — gcc_version","text":"","code":"gcc_version()"},{"path":"/reference/gcc_version.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks default c++ compiler — gcc_version","text":"returns string representation gcc, clang, c++ output","code":""},{"path":"/reference/gen_time_dep.html","id":null,"dir":"Reference","previous_headings":"","what":"Applies time dependence to parameters — gen_time_dep","title":"Applies time dependence to parameters — gen_time_dep","text":"gen_time_dep generates new dataframe time dependent covariates applying grid time","code":""},{"path":"/reference/gen_time_dep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Applies time dependence to parameters — gen_time_dep","text":"","code":"gen_time_dep(   df,   time1,   time2,   event0,   iscox,   dt,   new_names,   dep_cols,   func_form,   fname,   tform,   nthreads = as.numeric(detectCores()) )"},{"path":"/reference/gen_time_dep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Applies time dependence to parameters — gen_time_dep","text":"df data.table containing columns interest time1 column used time period starts time2 column used time period end event0 column used event status iscox boolean rows event times kept, rows removed true. Cox proportional hazards model use rows intervals containing event times dt spacing time new rows new_names list new names use instead default, default used entry ” dep_cols columns needed new dataframe func_form vector functions apply time-dependent covariate. form func(df, time) returning vector new column value fname filename used new dataframe tform list string function identifiers, used linear/step nthreads number threads use, use threads available machine","code":""},{"path":"/reference/gen_time_dep.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Applies time dependence to parameters — gen_time_dep","text":"returns updated dataframe","code":""},{"path":[]},{"path":"/reference/gen_time_dep.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Applies time dependence to parameters — gen_time_dep","text":"","code":"library(data.table) # Adapted from the tests a <- c(20, 20, 5, 10, 15) b <- c(1, 2, 1, 1, 2) c <- c(0, 0, 1, 1, 1) df <- data.table::data.table(\"a\" = a, \"b\" = b, \"c\" = c) time1 <- \"%trunc%\" time2 <- \"a\" event <- \"c\" control <- list(   \"lr\" = 0.75, \"maxiter\" = -1, \"halfmax\" = 5, \"epsilon\" = 1e-9,   \"deriv_epsilon\" = 1e-9, \"abs_max\" = 1.0, \"change_all\" = TRUE,   \"dose_abs_max\" = 100.0,   \"verbose\" = FALSE, \"ties\" = \"breslow\", \"double_step\" = 1 ) grt_f <- function(df, time_col) {   return((df[, \"b\"] * df[, get(time_col)])[[1]]) } func_form <- c(\"lin\") df_new <- gen_time_dep(   df, time1, time2, event, TRUE, 0.01, c(\"grt\"), c(),   c(grt_f), paste(\"test\", \"_new.csv\", sep = \"\"), func_form, 2 ) file.remove(\"test_new.csv\") #> [1] TRUE"},{"path":"/reference/get_os.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks system OS — get_os","title":"Checks system OS — get_os","text":"get_os checks system OS, part configuration script","code":""},{"path":"/reference/get_os.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks system OS — get_os","text":"","code":"get_os()"},{"path":"/reference/get_os.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks system OS — get_os","text":"returns string representation OS","code":""},{"path":"/reference/interact_them.html","id":null,"dir":"Reference","previous_headings":"","what":"Defines Interactions — interact_them","title":"Defines Interactions — interact_them","text":"interact_them uses user provided interactions define interaction terms update data.table. assumes interaction \"+\" \"*\" applies basic anti-aliasing avoid duplicates","code":""},{"path":"/reference/interact_them.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defines Interactions — interact_them","text":"","code":"interact_them(df, interactions, new_names, verbose = 0)"},{"path":"/reference/interact_them.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Defines Interactions — interact_them","text":"df data.table containing columns interest interactions array strings, one form term1?*?term2\" term1 interaction type * + term2, \"?\" dlimits new_names list new names use instead default, default used entry ” verbose integer valued 0-4 controlling information printed terminal. level includes lower levels. 0: silent, 1: errors printed, 2: warnings printed, 3: notes printed, 4: debug information printed. Errors situations stop regression, warnings situations assume default values user might intended, notes provide information regression progress, debug prints C++ progress intermediate results. default level 2 True/False converted 3/0.","code":""},{"path":"/reference/interact_them.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Defines Interactions — interact_them","text":"returns list two named fields. df updated dataframe, cols new column names","code":""},{"path":[]},{"path":"/reference/interact_them.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Defines Interactions — interact_them","text":"","code":"library(data.table) a <- c(0, 1, 2, 3, 4, 5, 6) b <- c(1, 2, 3, 4, 5, 6, 7) c <- c(0, 1, 2, 1, 0, 1, 0) df <- data.table::data.table(\"a\" = a, \"b\" = b, \"c\" = c) interactions <- c(\"a?+?b\", \"a?*?c\") new_names <- c(\"ab\", \"ac\") vals <- interact_them(df, interactions, new_names) df <- vals$df new_col <- vals$cols"},{"path":"/news/index.html","id":"colossus-09","dir":"Changelog","previous_headings":"","what":"Colossus 0.9","title":"Colossus 0.9","text":"Added NEWS.md file track changes package.","code":""},{"path":"/news/index.html","id":"colossus-100","dir":"Changelog","previous_headings":"","what":"Colossus 1.0.0","title":"Colossus 1.0.0","text":"CRAN release: 2024-02-20 Initial submission C++ code modified apply OpenMP code OpenMP isn’t detected, resolve MacOS installation failures","code":""},{"path":"/news/index.html","id":"colossus-101","dir":"Changelog","previous_headings":"","what":"Colossus 1.0.1","title":"Colossus 1.0.1","text":"CRAN release: 2024-02-26 Configuration improved detect compiler information Linux configuration depends system wide c++ default compiler used compile R OpenMP support used c++ default R compiler clang","code":""},{"path":"/news/index.html","id":"colossus-102","dir":"Changelog","previous_headings":"","what":"Colossus 1.0.2","title":"Colossus 1.0.2","text":"utility checks updated check keep_constant 0/1 values code fail keep_constant integer valued 0/1, explanation ","code":""},{"path":"/news/index.html","id":"colossus-103","dir":"Changelog","previous_headings":"","what":"Colossus 1.0.3","title":"Colossus 1.0.3","text":"configuration script libraries moved Suggested: Imports: configuration script functions moved non-exported functions Colossus, circumvents note imported libraries used may later used provide user function informs OpenMP /isn’t supported","code":""},{"path":"/news/index.html","id":"colossus-104","dir":"Changelog","previous_headings":"","what":"Colossus 1.0.4","title":"Colossus 1.0.4","text":"utility checks updated check term numbers subterm types R side code fail term numbers integers, term numbers missing, subterm types ","code":""},{"path":"/news/index.html","id":"colossus-105","dir":"Changelog","previous_headings":"","what":"Colossus 1.0.5","title":"Colossus 1.0.5","text":"compilation flags changed macros","code":""},{"path":"/news/index.html","id":"colossus-110","dir":"Changelog","previous_headings":"","what":"Colossus 1.1.0","title":"Colossus 1.1.0","text":"CRAN release: 2024-04-03 Default Makevars now fully portable default windows uses OpenMP now GitHub version include instructions activating configuration use OpenMP gcc Linux","code":""},{"path":"/news/index.html","id":"colossus-111","dir":"Changelog","previous_headings":"","what":"Colossus 1.1.1","title":"Colossus 1.1.1","text":"CRAN release: 2024-04-30 ggplot2 longer required, now optional additional testing added coverage default Makevars added via bash script","code":""},{"path":"/news/index.html","id":"colossus-112","dir":"Changelog","previous_headings":"","what":"Colossus 1.1.2","title":"Colossus 1.1.2","text":"Log-likelihood bound functionality added subject usual convergence issues, manual search option","code":""},{"path":"/news/index.html","id":"colossus-113","dir":"Changelog","previous_headings":"","what":"Colossus 1.1.3","title":"Colossus 1.1.3","text":"CRAN release: 2024-09-06 Cox regression now removes rows end first event start last event Cox regression now sets constant rows constant, helps aliasing Tests now use sink() avoid printing much excessive output console. Tests now consolidated .","code":""},{"path":"/news/index.html","id":"colossus-1141","dir":"Changelog","previous_headings":"","what":"Colossus 1.1.4.1","title":"Colossus 1.1.4.1","text":"CRAN release: 2024-09-20 Cox plotting functions now return tables used plots (last plot table returned) Plotting vignette updated include details plots survival package listed suggested plotting vignette","code":""},{"path":"/news/index.html","id":"colossus-1142","dir":"Changelog","previous_headings":"","what":"Colossus 1.1.4.2","title":"Colossus 1.1.4.2","text":"CRAN release: 2024-10-21 R errors warnings sent stop() warning(). C++ errors warnings still controlled verbosity argument ggsave defaults width/height = 7 Updates started fix possible OpenMP issues fedora 36 running clang 18 Unable debug printing option cover c++ files testing, still test output readable. debug output removed.","code":""},{"path":"/news/index.html","id":"colossus-115","dir":"Changelog","previous_headings":"","what":"Colossus 1.1.5","title":"Colossus 1.1.5","text":"Started adding simplifications allow faster iterations Added simplification linear ERR model Started gradient descent code Started external rate comparison options Added person-count person-time table generation code vignette","code":""},{"path":"/news/index.html","id":"colossus-1155","dir":"Changelog","previous_headings":"","what":"Colossus 1.1.5.5","title":"Colossus 1.1.5.5","text":"Added CoxCurveSolver function solve likelihood boundaries via bisection method","code":""},{"path":"/news/index.html","id":"colossus-116","dir":"Changelog","previous_headings":"","what":"Colossus 1.1.6","title":"Colossus 1.1.6","text":"MacOS testing OpenMP finished. MacOS use OpenMP officially checked. default systems forced use single thread linux using clang. can turned setting “R_COLOSSUS_NOT_CRAN” environment variable.","code":""},{"path":"/news/index.html","id":"colossus-117","dir":"Changelog","previous_headings":"","what":"Colossus 1.1.7","title":"Colossus 1.1.7","text":"Gradient descent algorithms tested presented vignette Multiple realization function tested ","code":""},{"path":"/news/index.html","id":"colossus-118","dir":"Changelog","previous_headings":"","what":"Colossus 1.1.8","title":"Colossus 1.1.8","text":"CurveSolve functions converted c++ functions Testing scaled back take less time","code":""},{"path":"/news/index.html","id":"colossus-119","dir":"Changelog","previous_headings":"","what":"Colossus 1.1.9","title":"Colossus 1.1.9","text":"Cox based functions switched covariance matrix calculation negative inverse log-likelihood second derivative, expected information matrix.","code":""},{"path":"/news/index.html","id":"colossus-1110","dir":"Changelog","previous_headings":"","what":"Colossus 1.1.10","title":"Colossus 1.1.10","text":"Cox based functions updated improve speed Additional CurveSolve output provided give final window width final step","code":""},{"path":"/news/index.html","id":"colossus-12","dir":"Changelog","previous_headings":"","what":"Colossus 1.2","title":"Colossus 1.2","text":"CRAN release: 2025-02-13 Cox Poisson functions now return expected information matrix derived covariance","code":""},{"path":"/news/index.html","id":"colossus-121","dir":"Changelog","previous_headings":"","what":"Colossus 1.2.1","title":"Colossus 1.2.1","text":"Matched Case-Control base code equation vignette added","code":""}]
